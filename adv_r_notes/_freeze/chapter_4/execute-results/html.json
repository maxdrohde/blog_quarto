{
  "hash": "d339518074e9c12cc902ddcd3cdd3e73",
  "result": {
    "markdown": "# Subsetting\n\n## Six ways to subset a vector\n\n:::{.callout-note}\nThe following rules works for atomic vectors and lists.\n:::\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# We'll use this vector as an example\nx <- c(2.1, 4.2, 3.3, 5.4)\n```\n:::\n\n\n\n### Positive integers\n\nGet elements at specified positions\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx[c(3, 1)]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 3.3 2.1\n```\n:::\n:::\n\n\nYou can duplicate indices.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx[c(1, 1)]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 2.1 2.1\n```\n:::\n:::\n\n\nDecimals are truncated if provided as indices.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx[c(2.1, 2.9)]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 4.2 4.2\n```\n:::\n:::\n\n\n### Negative integers\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx[c(-3, -1)]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 4.2 5.4\n```\n:::\n:::\n\n\nYou can't mix positive and negative integers.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx[c(-3, 1)]\n```\n:::\n\n\n### Nothing and Zero\n\nNothing returns the original vector:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx[]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 2.1 4.2 3.3 5.4\n```\n:::\n:::\n\n\nZero returns a zero-length vector:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx[0]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nnumeric(0)\n```\n:::\n:::\n\n\nand is ignored when used with other values:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx[c(0,3,1,0,0,0,2)]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 3.3 2.1 4.2\n```\n:::\n:::\n\n\n\n### Character vectors\n\nIf a vector is named, you can subset with character vectors:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ny <- setNames(x, letters[1:4])\n\nprint(y)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n  a   b   c   d \n2.1 4.2 3.3 5.4 \n```\n:::\n\n```{.r .cell-code}\ny[c(\"d\", \"c\", \"a\")]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n  d   c   a \n5.4 3.3 2.1 \n```\n:::\n\n```{.r .cell-code}\ny[c(\"a\", \"a\", \"a\")]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n  a   a   a \n2.1 2.1 2.1 \n```\n:::\n:::\n\n\nNames must be matched exactly:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nz <- c(abc = 1, def = 2)\n\nz[c(\"a\", \"d\")]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n<NA> <NA> \n  NA   NA \n```\n:::\n:::\n\n\n\n\n### Subsetting with factors (don't do it)\n\n\n::: {.cell}\n\n```{.r .cell-code}\nb <- factor(\"b\")\n\nprint(b)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] b\nLevels: b\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- c(a=1, b=2, c=3)\n```\n:::\n\n\nNotice how the integer representation of the factor is used for subsetting, which gives a counterintuitive result.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx[b]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\na \n1 \n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nx[\"b\"]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nb \n2 \n```\n:::\n:::\n\n\n## Selecting a single element\n\nUse ``[[ ]]`` when selected a single element.\n\n`$` is a shortcut for ``[[ ]]`` that can also do partial matching.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- list(abc = 1, def = 2, ghi = 3)\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nx[[\"g\"]]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nNULL\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n# Both of these work due to partial matching\n\nx$ghi\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 3\n```\n:::\n\n```{.r .cell-code}\nx$g\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 3\n```\n:::\n:::\n\n\n## Subsetting and assignment\n\nYou can combine subsetting with assignment to modify objects in R.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- list(1, 2, a = 3, \"abc\", 1:5)\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nx[\"a\"] <- 15\n\nprint(x)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[[1]]\n[1] 1\n\n[[2]]\n[1] 2\n\n$a\n[1] 15\n\n[[4]]\n[1] \"abc\"\n\n[[5]]\n[1] 1 2 3 4 5\n```\n:::\n:::\n\n\nRemove an element by setting it to `NULL`\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx[\"a\"] <- NULL\n\nprint(x)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[[1]]\n[1] 1\n\n[[2]]\n[1] 2\n\n[[3]]\n[1] \"abc\"\n\n[[4]]\n[1] 1 2 3 4 5\n```\n:::\n:::\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}