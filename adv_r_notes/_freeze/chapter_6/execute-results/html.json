{
  "hash": "c659c01bcf52d66339c8c6fe2eb66dc3",
  "result": {
    "markdown": "# Functions\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(tidyverse)\nlibrary(bench)\n```\n:::\n\n\n## Parts of functions\n\nFunctions have three parts:\n\n- Arguments\n- Body\n- Environment\n\nFunctions are objects.\n\nLet's use `sd()` as an example.\n\n`formals()` tells you about the arguments to a function.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nformals(sd)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n$x\n\n\n$na.rm\n[1] FALSE\n```\n:::\n:::\n\n\n`body()` gives you the code:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nbody(sd)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nsqrt(var(if (is.vector(x) || is.factor(x)) x else as.double(x), \n    na.rm = na.rm))\n```\n:::\n:::\n\n\nand `environment()` describes how the function finds the values associated with variables:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nenvironment(sd)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n<environment: namespace:stats>\n```\n:::\n:::\n\n\nFunctions can also have attributes just like other objects.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nstr(sd)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nfunction (x, na.rm = FALSE)  \n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nattr(sd, \"greeting\") <- \"hello\"\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nstr(sd)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nfunction (x, na.rm = FALSE)  \n - attr(*, \"greeting\")= chr \"hello\"\n```\n:::\n:::\n\n\n:::{.callout-note}\n## A note about primative functions\n\n\"Primitive functions are only found in the base package. While they have certain performance advantages, this benefit comes at a price: they are harder to write. For this reason, R-core generally avoids creating them unless there is no other option.\"\n:::\n\n## Creating functions\n\nYou can create anonymous functions a few ways:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n(function(x) x^2)(5)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 25\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n# New shorthand way of creating anonymous functions\n(\\(x) x^2)(5)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 25\n```\n:::\n:::\n\n\nFunctions can be put in a list:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmy_funcs <-\n  list(\n    \\(x) x^2,\n    \\(x) x^3,\n    \\(x) x^4\n  )\n\nfor (f in my_funcs) {\n  print(f(2))\n}\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 4\n[1] 8\n[1] 16\n```\n:::\n:::\n\n\nWhen you run a function, the arguments can be put into a list and evaluated with the `do.call` function:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nargs <- list(1:10, na.rm = TRUE)\n\ndo.call(mean, args)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 5.5\n```\n:::\n:::\n\n\n## Function environments\n\nIf an object is used in a function, but is not defined within that function, R will look in the environments \"above\" it.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ng12 <- function() x + 1\n\nx <- 15\ng12()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 16\n```\n:::\n\n```{.r .cell-code}\nx <- 20\ng12()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 21\n```\n:::\n:::\n\n\nThis can lead to unintended consequences. We can use `codetools::findGlobals()` to list external variables within a function.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncodetools::findGlobals(g12)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"+\" \"x\"\n```\n:::\n:::\n\n\nThis is an interesting piece of code to reason about function environments:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ny <- 10\nf <- function(x) {\n  y <- 100\n  x + 1\n}\n\nf(y)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 11\n```\n:::\n:::\n\n\nThis piece of code is interesting to puzzle over:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n(\\(x) x+1)(y <- 1000)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 1001\n```\n:::\n\n```{.r .cell-code}\ny\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 1000\n```\n:::\n:::\n\n\n## Lazy evaluation\n\nFunctions in R are lazily evaluated.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# This code doesn't raise an error because `x` is not used\n\nf <- function(x) {\n  10\n}\nf(stop(\"This is an error!\"))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 10\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n# This code does raise an error\n\nf <- function(x) {\n  x\n}\nf(stop(\"This is an error!\"))\n```\n:::\n\n\nYou can define default values in terms of other arguments or even variables defined in the function (not recommended).\n\n\n::: {.cell}\n\n```{.r .cell-code}\nf <- function(x = 1, y = x * 2, z = a + b) {\n  a <- 10\n  b <- 100\n  \n  c(x, y, z)\n}\n\nf()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1]   1   2 110\n```\n:::\n:::\n\n\n\n## ... (dot-dot-dot)\n\n## Function forms\n\n- prefix\n- infix\n- replacement\n- special\n\n\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}