{
  "hash": "e669d63b66ce62e9e81501ac3df41fd7",
  "result": {
    "markdown": "# Names and values\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# This package lets us look at the representation of R objects\nlibrary(lobstr)\n\n# Allow inclusion of documentation in Quarto\nlibrary(printr)\n\n# Precise timing of functions\nlibrary(bench)\n\nlibrary(tidyverse)\n\n# Set global ggplot theme\ntheme_set(cowplot::theme_cowplot(font_size=12,\n                                 font_family = \"Source Sans Pro\"))\n```\n:::\n\n\nAn object is different than it's name.\n\n## Quiz\n\n### Q1\n\nGiven the following data frame, how do I create a new column called \"3\" that contains the sum of `1` and `2`? You may only use `$`, not `[[`. What makes `1`, `2`, and `3` challenging as variable names?\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndf <- data.frame(runif(3), runif(3))\nnames(df) <- c(1, 2)\n```\n:::\n\n\n### Solution\n\nYou need to use backticks to specify non-standard column names.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndf$`3` <- df$`1` + df$`2`\n\ndf\n```\n\n::: {.cell-output-display}\n|         1|         2|         3|\n|---------:|---------:|---------:|\n| 0.2784256| 0.4897584| 0.7681840|\n| 0.5630199| 0.9345367| 1.4975566|\n| 0.4917291| 0.2493742| 0.7411033|\n:::\n:::\n\n\n### Q2\n\nIn the following code, how much memory does `y` occupy?\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- runif(1e6)\ny <- list(x, x, x)\n```\n:::\n\n\n### Solution\n\nTBD\n\n### Q3\n\nOn which line does `a` get copied in the following example?\n\n\n::: {.cell}\n\n```{.r .cell-code}\na <- c(1, 5, 3, 2)\nb <- a\nb[[1]] <- 10\n```\n:::\n\n\n### Solution\n\nTBD\n\n## Chapter Notes\n\n### Difference between names and values\n\nWhat happens when we create `x`?\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- c(1, 2, 3)\n```\n:::\n\n\n- A vector `(1,2,3)` is created.\n- A name `x` is created, which points to the above vector.\n\nNow what if we assign `x` to a new variable?\n\n\n::: {.cell}\n\n```{.r .cell-code}\ny <- x\n```\n:::\n\n\nDoes the original vector get copied (i.e., are we now effectively storing 6 numbers)? No, we are still only storing 3 numbers because `y` and `x` are pointing to the same underlying object.\n\nHere's how we can verify that this is true:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlobstr::obj_addr(x) # Address of the object that x points to\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"0x7fc9fd1f0258\"\n```\n:::\n\n```{.r .cell-code}\nlobstr::obj_addr(y) # Address of the object that y points to\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"0x7fc9fd1f0258\"\n```\n:::\n\n```{.r .cell-code}\nlobstr::obj_addr(x) == lobstr::obj_addr(y) # See that they are equal\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] TRUE\n```\n:::\n:::\n\n\n### What are valid names?\n\n> A syntactic name must consist of letters, digits, `.` and `_` but can’t begin with `_` or a digit. Additionally, you can’t use any of the reserved words like `TRUE`, `NULL`, `if`, and `function` (see the complete list in `?Reserved`).\n\n:::{.callout-note collapse=\"true\"}\n## Expand to read full rules on syntactic names\n\n\n::: {.cell}\n\n```{.r .cell-code}\n?make.names\n```\n\n::: {.cell-output-display}\n`````{=html}\n<div class=\"r-help-page\"><div class=\"container\">\n\n<table width=\"100%\" summary=\"page for make.names\"><tr><td>make.names</td><td style=\"text-align: right;\">R Documentation</td></tr></table>\n\n<h2>Make Syntactically Valid Names</h2>\n\n<h3>Description</h3>\n\n<p>Make syntactically valid names out of character vectors.\n</p>\n\n\n<h3>Usage</h3>\n\n<pre class=\"r\">\nmake.names(names, unique = FALSE, allow_ = TRUE)\n</pre>\n\n\n<h3>Arguments</h3>\n\n<table summary=\"R argblock\">\n<tr valign=\"top\"><td><code>names</code></td>\n<td>\n<p>character vector to be coerced to syntactically valid\nnames.  This is coerced to character if necessary.</p>\n</td></tr>\n<tr valign=\"top\"><td><code>unique</code></td>\n<td>\n<p>logical; if <code>TRUE</code>, the resulting elements are\nunique.  This may be desired for, e.g., column names.</p>\n</td></tr>\n<tr valign=\"top\"><td><code>allow_</code></td>\n<td>\n<p>logical.  For compatibility with <span style=\"font-family: Courier New, Courier; color: #666666;\"><b>R</b></span> prior to 1.9.0.</p>\n</td></tr>\n</table>\n\n\n<h3>Details</h3>\n\n<p>A syntactically valid name consists of letters, numbers and the dot or\nunderline characters and starts with a letter or the dot not followed\nby a number.  Names such as <code>\".2way\"</code> are not valid, and neither\nare the reserved words.\n</p>\n<p>The definition of a <em>letter</em> depends on the current locale, but\nonly ASCII digits are considered to be digits.\n</p>\n<p>The character <code>\"X\"</code> is prepended if necessary.\nAll invalid characters are translated to <code>\".\"</code>.  A missing value\nis translated to <code>\"NA\"</code>.  Names which match <span style=\"font-family: Courier New, Courier; color: #666666;\"><b>R</b></span> keywords have a dot\nappended to them.  Duplicated values are altered by\n<code>make.unique</code>.\n</p>\n\n\n<h3>Value</h3>\n\n<p>A character vector of same length as <code>names</code> with each changed to\na syntactically valid name, in the current locale's encoding.\n</p>\n\n\n<h3>Warning</h3>\n\n<p>Some OSes, notably FreeBSD, report extremely incorrect information about\nwhich characters are alphabetic in some locales (typically, all\nmulti-byte locales including UTF-8 locales).  However, <span style=\"font-family: Courier New, Courier; color: #666666;\"><b>R</b></span> provides\nsubstitutes on Windows, macOS and AIX.\n</p>\n\n\n<h3>Note</h3>\n\n<p>Prior to <span style=\"font-family: Courier New, Courier; color: #666666;\"><b>R</b></span> version 1.9.0, underscores were not valid in variable names,\nand code that relies on them being converted to dots will no longer\nwork. Use <code>allow_ = FALSE</code> for back-compatibility.\n</p>\n<p><code>allow_ = FALSE</code> is also useful when creating names for export to\napplications which do not allow underline in names (for example,\nS-PLUS and some DBMSes).\n</p>\n\n\n<h3>See Also</h3>\n\n<p><code>make.unique</code>,\n<code>names</code>,\n<code>character</code>,\n<code>data.frame</code>.\n</p>\n\n\n<h3>Examples</h3>\n\n<pre class=\"r\">\nmake.names(c(\"a and b\", \"a-and-b\"), unique = TRUE)\n# \"a.and.b\"  \"a.and.b.1\"\nmake.names(c(\"a and b\", \"a_and_b\"), unique = TRUE)\n# \"a.and.b\"  \"a_and_b\"\nmake.names(c(\"a and b\", \"a_and_b\"), unique = TRUE, allow_ = FALSE)\n# \"a.and.b\"  \"a.and.b.1\"\nmake.names(c(\"\", \"X\"), unique = TRUE)\n# \"X.1\" \"X\" currently; R up to 3.0.2 gave \"X\" \"X.1\"\n\nstate.name[make.names(state.name) != state.name] # those 10 with a space\n</pre>\n\n\n</div></div>\n`````\n:::\n:::\n\n\n:::\n\n:::{.callout-note collapse=\"true\"}\n## Expand to read the `Reserved` documentation\n\n\n::: {.cell}\n\n```{.r .cell-code}\n?Reserved\n```\n\n::: {.cell-output-display}\n`````{=html}\n<div class=\"r-help-page\"><div class=\"container\">\n\n<table width=\"100%\" summary=\"page for Reserved\"><tr><td>Reserved</td><td style=\"text-align: right;\">R Documentation</td></tr></table>\n\n<h2>Reserved Words in R</h2>\n\n<h3>Description</h3>\n\n<p>The reserved words in <span style=\"font-family: Courier New, Courier; color: #666666;\"><b>R</b></span>'s parser are\n</p>\n<p><code>if</code> <code>else</code> <code>repeat</code> <code>while</code>\n<code>function</code> <code>for</code> <code>in</code>\n<code>next</code> <code>break</code>\n</p>\n<p><code>TRUE</code> <code>FALSE</code> <code>NULL</code>\n<code>Inf</code> <code>NaN</code>\n<code>NA</code> <code>NA_integer_</code> <code>NA_real_</code>\n<code>NA_complex_</code> <code>NA_character_</code>\n</p>\n<p><code>...</code> and <code>..1</code>, <code>..2</code> etc, which are used to refer to\narguments passed down from a calling function, see <code>...</code>.\n</p>\n\n\n<h3>Details</h3>\n\n<p>Reserved words outside quotes are always parsed to be\nreferences to the objects linked to in the &lsquo;Description&rsquo;, and\nhence they are not allowed as syntactic names (see\n<code>make.names</code>).  They <b>are</b> allowed as non-syntactic\nnames, e.g. inside backtick quotes.\n</p>\n\n\n</div></div>\n`````\n:::\n:::\n\n:::\n\nHowever, you can circumvent these rules by using backticks.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Note that this leaves the reserved keyword \"if\" untouched\n# since if and `if` are different\n`if` <- 10\n```\n:::\n\n\n\n### Copy-on-modify\n\nR objects are only copied when they need to be. This saves memory.\n\nFor example,\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- 17\ny <- x\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n# x and y point to the same object\nlobstr::obj_addr(x) == lobstr::obj_addr(y)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] TRUE\n```\n:::\n:::\n\n\nAt first, `x` and `y` point to the same object. Now we modify `x`. When we do this, the object that holds the number `17` is copied so that `x` and `y` have seperate objects that they point to.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- x*2\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nx\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 34\n```\n:::\n\n```{.r .cell-code}\ny\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 17\n```\n:::\n\n```{.r .cell-code}\n# x and y point to the different objects now\nlobstr::obj_addr(x) == lobstr::obj_addr(y)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] FALSE\n```\n:::\n:::\n\n\n### Columns vs Rows\n\nThe copy-on-modify behavior of R has implication for speed when operating on columns of a data frame vs. the rows.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nf1 <- function(){\n  df <-\n    runif(50*50) %>%\n    matrix(nrow=50, ncol=50) %>%\n    as.data.frame()\n  \n  for (i in 1:nrow(df)) {\n    df[i,] <- df[i,]*2\n  }\n}\n\nf2 <- function(){\n  df <-\n    runif(50*50) %>%\n    matrix(nrow=50, ncol=50) %>%\n    as.data.frame()\n  \n  for (i in 1:ncol(df)) {\n    df[,i] <- df[,i]*2\n  }\n}\n```\n:::\n\n::: {.cell .column-body-outset-right}\n\n```{.r .cell-code}\nbench::mark(`Operate on rows` = f1(),\n            `Operate on columns` = f2(),\n            iterations = 1e4,\n            time_unit = \"ms\") %>%\n  mutate(expression = as.character(expression)) %>%\n  unnest_longer(time) %>%\n  mutate(time = as.numeric(time) * 1000) %>%\n  ggplot() +\n  aes(x=time) +\n  geom_histogram(bins=100, color=\"black\", fill=\"lightgray\") +\n  scale_x_log10() +\n  facet_wrap(~expression, nrow = 2) +\n  labs(x = \"Time (ms)\",\n       y = \"Trials\")\n```\n\n::: {.cell-output-display}\n![](chapter_2_files/figure-html/unnamed-chunk-17-1.png){width=960}\n:::\n:::\n",
    "supporting": [
      "chapter_2_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}