{
  "hash": "cd00a01d65378bd8acb3e587077925fc",
  "result": {
    "markdown": "# Vectors\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(tidyverse)\n```\n:::\n\n\n\n## Attributes\n\nSet an attribute with `attr()`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- c(1,3,5)\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nstr(x)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n num [1:3] 1 3 5\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nattr(x, \"y\") <- \"hello\"\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nx\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 1 3 5\nattr(,\"y\")\n[1] \"hello\"\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nstr(x)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n num [1:3] 1 3 5\n - attr(*, \"y\")= chr \"hello\"\n```\n:::\n:::\n\n\nCreate an object with attributes using `structure()`\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmy_struc <-\n  structure(c(1,3,5),\n            color=\"red\",\n            name = \"max\")\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nmy_struc\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 1 3 5\nattr(,\"color\")\n[1] \"red\"\nattr(,\"name\")\n[1] \"max\"\n```\n:::\n:::\n\n\nIf you give the `dim` attribute to a vector, it will become a matrix.\n\n\n::: {.cell}\n\n```{.r .cell-code}\na <- 1:10\n\nprint(a)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n [1]  1  2  3  4  5  6  7  8  9 10\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n# Give it 2 rows and 5 columns\ndim(a) <- c(2,5)\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nprint(a)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n     [,1] [,2] [,3] [,4] [,5]\n[1,]    1    3    5    7    9\n[2,]    2    4    6    8   10\n```\n:::\n:::\n\n\nA cool fact is that you can create \"list-matrices\" by passing the `dim` attribute to a list.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nl <- list(c(1L, 2L, 3L),\n          \"a\",\n          TRUE,\n          1.0)\n\nprint(l)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[[1]]\n[1] 1 2 3\n\n[[2]]\n[1] \"a\"\n\n[[3]]\n[1] TRUE\n\n[[4]]\n[1] 1\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ndim(l) <- c(2, 2)\n\nprint(l)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n     [,1]      [,2]\n[1,] integer,3 TRUE\n[2,] \"a\"       1   \n```\n:::\n:::\n\n\n## Factors\n\nYou can make a factor by specifying the proper attributes: `class` and `levels`. Note that this will only work on a vector of integers.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- c(1L, 1L, 2L, 2L, 3L, 3L)\n\n# This won't work because these aren't integers.\n# x <- c(1,1,2,2,3,3)\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nattributes(x) <- list(class=\"factor\",\n                      levels=c(\"a\", \"b\", \"c\"))\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n# Now we have a factor!\nprint(x)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] a a b b c c\nLevels: a b c\n```\n:::\n:::\n\n\n## Data Frames\n\nImportant point:\n\n> A data frame is a named list of vectors with attributes for (column) `names`, `row.names`, and its class, `data.frame`.\n\n> [T]he length of each of its vectors must be the same\n\n`names()` is the same as `colnames()` for data frames.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nnames(mtcars) == colnames(mtcars)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n [1] TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE\n```\n:::\n:::\n\n\nThe length of a data frame is the number of columns.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlength(mtcars) == ncol(mtcars)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] TRUE\n```\n:::\n\n```{.r .cell-code}\nlength(mtcars) != nrow(mtcars)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] TRUE\n```\n:::\n:::\n\n\n> [T]ibbles will only recycle vectors of length one\n\n> `tibble()` allows you to refer to variables created during construction\n\nData frames can have list-columns.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntibble(x = 1:3,\n       y = list(1:2, 1:3, 1:4))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 3 × 2\n      x y        \n  <int> <list>   \n1     1 <int [2]>\n2     2 <int [3]>\n3     3 <int [4]>\n```\n:::\n:::\n\n\nElements of a data frame can also be matrices, arrays, or other data frames!\n\n## NULL\n\nTwo uses of `NULL`:\n\n> To represent an empty vector (a vector of length zero) of arbitrary type. For example, if you use `c()` but don’t include any arguments, you get `NULL`, and concatenating `NULL` to a vector will leave it unchanged.\n\n> To represent an absent vector. For example, `NULL` is often used as a default function argument, when the argument is optional but the default value requires some computation. Contrast this with NA which is used to indicate that an element of a vector is absent.\n\n\n\n\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}