{
  "hash": "e957e0873a14a206e352e24225bb0a97",
  "result": {
    "markdown": "---\ntitle: \"Seth June 7th\"\nauthor: \"Max Rohde\"\ndate: \"2022-06-08\"\ntoc: true\ntoc-depth: 4\ntoc-location: left\ncache: false\nformat:\n  html:\n    code-tools: true\n    code-fold: show\n    code-link: true\n    code-block-bg: \"#f1f3f5\"\n    code-block-border-left: \"#31BAE9\"\n    mainfont: Source Sans Pro\n    theme: journal\n    fontsize: 16px\n    fig-format: retina\n    fig-cap-location: margin\n    tbl-cap-location: top\n    reference-location: margin\n    citation-location: margin\n    fig-width: 8\n    fig-height: 6\n  \nexecute:\n  warning: false\n  message: false\n---\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(tidyverse)\n\n# Set default ggplot theme\n# Set global ggplot theme\ntheme_set(cowplot::theme_cowplot(font_size=12))\n```\n:::\n\n\n## Question\n\n```\nI have another question:  I want to filter my df based on different criteria in a loop or using the map functions\n \nData:\ndf <- tibble(ID1 = c(\"A\", \"A\", \"A\",\"B\", \"B\", \"c\", \"D\"),\n             ID2 = c(1,1,2,2,3,4,5))\n \nWhat I want\nFirst I want to filter it such that ID1 = “A” & ID2 = 2 (1 observation)\nThen I want to filter it so ID1 = B & ID2 = 3 (1 observation)\n \nSo I know I can store those criteria in vectors, then call those vectors in the filter function:\nid1 <- \"A\"\nid2 <- 2\nThen\nid1 <- \"B\"\nid2 <- 3\n \ndf %>%\n        filter(ID1 == id1,\n         ID2 == id2)\n \nHowever, is there a way to create a list that has both combinations (A, 2 then B,3) then loop through that list , applying the filtering?\nSomething like:\nmap(list, filter_function) ?\n \nThe context is, I have a bunch of combinations of filtering criteria I don’t want to have to write out every time.\n```\n\n## Solution\n\nFirst we create a tibble of test data.\n\n::: {.cell}\n\n```{.r .cell-code}\ndf <- tibble(ID1 = c(\"A\", \"A\", \"A\",\"B\", \"B\", \"c\", \"D\"),\n             ID2 = c(1,1,2,2,3,4,5))\n```\n:::\n\n\nThen we create a custom filter function that inputs the dataset and filters to certain values for `ID1` and `ID2`.\n\n::: {.cell}\n\n```{.r .cell-code}\ncustom_filter <- function(df, id1, id2){\n  df %>%\n    filter(\n    ID1 == id1,\n    ID2 == id2\n    )\n}\n```\n:::\n\n\nWe can store the filtering critera as rows of a tibble. Here we use three criteria: (A, 1), (A, 2), and (B,3).\n\n::: {.cell}\n\n```{.r .cell-code}\nfiltering_criteria <- tibble(id1 = c(\"A\", \"A\", \"B\"),\n                           id2 = c(1, 2, 3))\n```\n:::\n\n\nIterate through our criterea and apply the custom filter to our data,\n\n::: {.cell}\n\n```{.r .cell-code}\nfiltered_dfs <- pmap(filtering_criteria, custom_filter, df=df)\n```\n:::\n\nWe now have a list of the three filtered data frames.\n\n::: {.cell}\n\n```{.r .cell-code}\nfiltered_dfs\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[[1]]\n# A tibble: 2 × 2\n  ID1     ID2\n  <chr> <dbl>\n1 A         1\n2 A         1\n\n[[2]]\n# A tibble: 1 × 2\n  ID1     ID2\n  <chr> <dbl>\n1 A         2\n\n[[3]]\n# A tibble: 1 × 2\n  ID1     ID2\n  <chr> <dbl>\n1 B         3\n```\n:::\n:::\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}