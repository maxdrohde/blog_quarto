{
  "hash": "20f41f6622a7ea86d32702cca873f6e8",
  "result": {
    "markdown": "---\ntitle: Linear Algebra / Matrix Operations in R\ndescription: Informal notes about common linear algebra / matrix operations in R\nauthor: Max Rohde\ndate: 04/29/2022\nimage: preview.png\ncode-fold: show\n---\n\n\nThe following material should be understandable to anyone with a basic knowledge of R and linear algebra. I plan to update this page with more material in the future.\n\n# Creating vectors\n\nVectors can be created with the `c()` function.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nc(1,3,7)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 1 3 7\n```\n:::\n:::\n\n\nFor vectors that are a continuous sequence of numbers, you can use the `:` operator.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n1:8\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 1 2 3 4 5 6 7 8\n```\n:::\n:::\n\n\nFor vectors of repeated numbers, such as a zero vector, use the `rep()` function.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Create a zero vector of length 10\nrep(0, times=10)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n [1] 0 0 0 0 0 0 0 0 0 0\n```\n:::\n\n```{.r .cell-code}\n# Or to be more concise\n# rep(0, 10)\n```\n:::\n\n\nMore complicated sequences can be created with the `seq()` function.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Create a sequence from 1 to 3 with a step size of 0.5\nseq(1,3, by = 0.5)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 1.0 1.5 2.0 2.5 3.0\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n# Create 10 equal spaced numbers between 1 and 3\nseq(1,3, length.out = 10)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n [1] 1.000000 1.222222 1.444444 1.666667 1.888889 2.111111 2.333333 2.555556\n [9] 2.777778 3.000000\n```\n:::\n:::\n\n\n# Creating matrices\n\nThere are two common ways to create matrices in R.\n\nThe first method is using the `matrix()` function. You pass the elements of the matrix into `matrix()` and specify the number of rows and columns. Note that R fills in the numbers going down each column. This can be unintuitive.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Put the numbers 1 to 12 in 3 rows and 4 columns\nmatrix(1:12, nrow=3, ncol=4)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n     [,1] [,2] [,3] [,4]\n[1,]    1    4    7   10\n[2,]    2    5    8   11\n[3,]    3    6    9   12\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n# Put the numbers 1 to 12 in 2 rows and 6 columns\nmatrix(1:12, nrow=2, ncol=6)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n     [,1] [,2] [,3] [,4] [,5] [,6]\n[1,]    1    3    5    7    9   11\n[2,]    2    4    6    8   10   12\n```\n:::\n:::\n\n\nThe second method is using `rbind()` and `cbind()`. Use `rbind()` to combine vectors into a matrix by row, and `cbind()` to combine vectors into a matrix by column.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx1 <- c(1,2,3,4)\nx2 <- c(5,6,7,8)\nx3 <- c(9,10,11,12) \n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nrbind(x1, x2, x3)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n   [,1] [,2] [,3] [,4]\nx1    1    2    3    4\nx2    5    6    7    8\nx3    9   10   11   12\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ncbind(x1, x2, x3)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n     x1 x2 x3\n[1,]  1  5  9\n[2,]  2  6 10\n[3,]  3  7 11\n[4,]  4  8 12\n```\n:::\n:::\n\n\nTo create a $n \\times n$ identity matrix, use the `diag(n)` function.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndiag(5)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n     [,1] [,2] [,3] [,4] [,5]\n[1,]    1    0    0    0    0\n[2,]    0    1    0    0    0\n[3,]    0    0    1    0    0\n[4,]    0    0    0    1    0\n[5,]    0    0    0    0    1\n```\n:::\n:::\n\n\nOnce a matrix is created, the `dim()` can be used to obtain the dimensions.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nm <- cbind(x1, x2, x3)\n\n# See that m has 4 rows and 3 columns\ndim(m)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 4 3\n```\n:::\n:::\n\n\nIf you are only interested in the number of rows and columns, use `nrow()` and `ncol()` respectively.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nnrow(m)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 4\n```\n:::\n\n```{.r .cell-code}\nncol(m)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 3\n```\n:::\n:::\n\n\n\n# Matrix indexing\n\nOnce you have a matrix in R, how do you subset parts of the matrix? Let's use this matrix, `m` as an example.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nm <- matrix(1:12, nrow=3, ncol=4)\n\nprint(m)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n     [,1] [,2] [,3] [,4]\n[1,]    1    4    7   10\n[2,]    2    5    8   11\n[3,]    3    6    9   12\n```\n:::\n:::\n\n\nThe syntax `m[i]` selects the ith element. Recall that R counts going down columns.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nm[2]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 2\n```\n:::\n:::\n\n\nThe syntax `m[i, ]` selects the ith row\n\n\n::: {.cell}\n\n```{.r .cell-code}\nm[2,]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1]  2  5  8 11\n```\n:::\n:::\n\n\nThe syntax `m[,i]` selects the ith column.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nm[,2]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 4 5 6\n```\n:::\n:::\n\n\nThe syntax `m[i,j]` selects the element in the ith row and jth column.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nm[2,2]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 5\n```\n:::\n:::\n\n\n# Matrix operations\n\nMatrix multiplication uses the `%*%` operator.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Define matrices\nA <- matrix(1:9, nrow=3, ncol=3)\nB <- matrix(1:6, nrow=3, ncol=2)\n\n# Matrix multiplication\nA %*% B\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n     [,1] [,2]\n[1,]   30   66\n[2,]   36   81\n[3,]   42   96\n```\n:::\n:::\n\n\nRemember that the order of matrix multiplication is important!\n\n\n::: {.cell}\n\n```{.r .cell-code}\nB %*% A\n```\n:::\n\n```\nError in B %*% A : non-conformable arguments\n```\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}