<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta charset="utf-8">
<meta name="generator" content="quarto-1.3.450">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">
<meta name="author" content="Max Rohde">
<meta name="dcterms.date" content="2022-11-10">
<meta name="description" content="Using cryptography to demonstrate the power of MCMC techniques in computational statistics">
<title>Max Rohde - Code-breaking with Markov Chain Monte Carlo (MCMC)</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
</style>

<script src="../../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../../site_libs/clipboard/clipboard.min.js"></script>
<script src="../../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../../site_libs/quarto-search/fuse.min.js"></script>
<script src="../../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../../">
<link href="../../images/favicon.png" rel="icon" type="image/png">
<script src="../../site_libs/quarto-html/quarto.js"></script>
<script src="../../site_libs/quarto-html/popper.min.js"></script>
<script src="../../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../../site_libs/quarto-html/anchor.min.js"></script>
<link href="../../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../../site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../../site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light"><script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 20,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script><style>

      .quarto-title-block .quarto-title-banner h1,
      .quarto-title-block .quarto-title-banner h2,
      .quarto-title-block .quarto-title-banner h3,
      .quarto-title-block .quarto-title-banner h4,
      .quarto-title-block .quarto-title-banner h5,
      .quarto-title-block .quarto-title-banner h6
      {
        color: black;
      }

      .quarto-title-block .quarto-title-banner {
        color: black;
background: #f1f3f5;
      }
</style>
<script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script><script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script><link rel="stylesheet" href="../../styles.css">
<meta property="og:title" content="Max Rohde - Code-breaking with Markov Chain Monte Carlo (MCMC)">
<meta property="og:description" content="Using cryptography to demonstrate the power of MCMC techniques in computational statistics">
<meta property="og:image" content="preview.png">
<meta property="og:site-name" content="Max Rohde">
<meta name="twitter:title" content="Max Rohde - Code-breaking with Markov Chain Monte Carlo (MCMC)">
<meta name="twitter:description" content="Using cryptography to demonstrate the power of MCMC techniques in computational statistics">
<meta name="twitter:image" content="preview.png">
<meta name="twitter:creator" content="@max_d_rohde">
<meta name="twitter:card" content="summary_large_image">
</head>
<body class="floating nav-fixed slimcontent">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top"><nav class="navbar navbar-expand-lg navbar-dark "><div class="navbar-container container-fluid">
      <div class="navbar-brand-container">
    <a class="navbar-brand" href="../../index.html">
    <span class="navbar-title">Max Rohde</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll ms-auto">
<li class="nav-item">
    <a class="nav-link" href="../../index.html" rel="" target="">
 <span class="menu-text">Blog</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../about.html" rel="" target="">
 <span class="menu-text">About</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../resume.pdf" rel="" target="">
 <span class="menu-text">Resume</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../anim.html" rel="" target="">
 <span class="menu-text">Animations</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../shiny.html" rel="" target="">
 <span class="menu-text">Shiny Apps</span></a>
  </li>  
</ul>
<div class="quarto-navbar-tools">
</div>
          </div> <!-- /navcollapse -->
      </div> <!-- /container-fluid -->
    </nav></header><!-- content --><header id="title-block-header" class="quarto-title-block default toc-left page-columns page-full"><div class="quarto-title-banner page-columns page-full">
    <div class="quarto-title column-body">
      <div class="quarto-title-block"><div><h1 class="title">Code-breaking with Markov Chain Monte Carlo (MCMC)</h1><button type="button" class="btn code-tools-button" id="quarto-code-tools-source"><i class="bi"></i> Code</button></div></div>
                  <div>
        <div class="description">
          Using cryptography to demonstrate the power of MCMC techniques in computational statistics
        </div>
      </div>
                </div>
  </div>
    
  
  <div class="quarto-title-meta">

      <div>
      <div class="quarto-title-meta-heading">Author</div>
      <div class="quarto-title-meta-contents">
               <p>Max Rohde </p>
            </div>
    </div>
      
      <div>
      <div class="quarto-title-meta-heading">Published</div>
      <div class="quarto-title-meta-contents">
        <p class="date">November 10, 2022</p>
      </div>
    </div>
    
      
    </div>
    
  
  </header><div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
  <nav id="quarto-sidebar" class="sidebar collapse collapse-horizontal sidebar-navigation floating overflow-auto"><nav id="TOC" role="doc-toc" class="toc-active"><h2 id="toc-title">On this page</h2>
   
  <ul>
<li><a href="#overview" id="toc-overview" class="nav-link active" data-scroll-target="#overview">Overview</a></li>
  <li><a href="#the-substitution-cipher" id="toc-the-substitution-cipher" class="nav-link" data-scroll-target="#the-substitution-cipher">The substitution cipher</a></li>
  <li>
<a href="#overview-of-the-metropolis-algorithm" id="toc-overview-of-the-metropolis-algorithm" class="nav-link" data-scroll-target="#overview-of-the-metropolis-algorithm">Overview of the Metropolis algorithm</a>
  <ul>
<li><a href="#why-not-use-brute-force" id="toc-why-not-use-brute-force" class="nav-link" data-scroll-target="#why-not-use-brute-force">Why not use brute force?</a></li>
  <li><a href="#the-metropolis-algorithm" id="toc-the-metropolis-algorithm" class="nav-link" data-scroll-target="#the-metropolis-algorithm">The Metropolis algorithm</a></li>
  </ul>
</li>
  <li>
<a href="#defining-an-english-similarity-score" id="toc-defining-an-english-similarity-score" class="nav-link" data-scroll-target="#defining-an-english-similarity-score">Defining an “English-similarity score”</a>
  <ul>
<li><a href="#estimating-frequencies-based-on-a-sample-text" id="toc-estimating-frequencies-based-on-a-sample-text" class="nav-link" data-scroll-target="#estimating-frequencies-based-on-a-sample-text">Estimating frequencies based on a sample text</a></li>
  <li><a href="#obtaining-two-character-frequencies" id="toc-obtaining-two-character-frequencies" class="nav-link" data-scroll-target="#obtaining-two-character-frequencies">Obtaining two-character frequencies</a></li>
  <li><a href="#estimated-frequencies-from-war-and-peace" id="toc-estimated-frequencies-from-war-and-peace" class="nav-link" data-scroll-target="#estimated-frequencies-from-war-and-peace">Estimated frequencies from <em>War and Peace</em></a></li>
  <li><a href="#getting-the-probability-of-a-new-text" id="toc-getting-the-probability-of-a-new-text" class="nav-link" data-scroll-target="#getting-the-probability-of-a-new-text">Getting the probability of a new text</a></li>
  </ul>
</li>
  <li><a href="#implementing-the-metropolis-algorithm" id="toc-implementing-the-metropolis-algorithm" class="nav-link" data-scroll-target="#implementing-the-metropolis-algorithm">Implementing the Metropolis Algorithm</a></li>
  </ul><div class="toc-actions"><div><i class="bi bi-github"></i></div><div class="action-links"><p><a href="https://github.com/maxdrohde/blog_quarto/edit/main/posts/code-breaking-with-metropolis/index.qmd" class="toc-action">Edit this page</a></p><p><a href="https://github.com/maxdrohde/blog_quarto/issues/new" class="toc-action">Report an issue</a></p></div></div></nav>
</nav><div id="quarto-sidebar-glass" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar,#quarto-sidebar-glass"></div>
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
    </div>
<!-- main -->
<main class="content quarto-banner-title-block page-columns page-full" id="quarto-document-content"><section id="overview" class="level2 page-columns page-full"><h2 class="anchored" data-anchor-id="overview">Overview</h2>
<div class="page-columns page-full"><p>In this post we will show how a common method in computational statistics, Markov Chain Monte Carlo (implemented using the Metropolis algorithm), can be used to decode hidden messages encoded using a substitution cipher<a href="#fn1" class="footnote-ref" id="fnref1" role="doc-noteref"><sup>1</sup></a>.</p><div class="no-row-height column-margin column-container"><li id="fn1"><p><sup>1</sup>&nbsp;From Merriam-Webster, a cipher is defined as “a method of transforming a text in order to conceal its meaning”.</p></li></div></div>
<p>To cut to the chase, here’s a video of the algorithm in action running on my laptop:</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure"><p><video src="demo.mp4" class="img-fluid" controls=""><a href="demo.mp4">Video</a></video></p>
</figure>
</div>
<div class="page-columns page-full"><p>We see that within a few hundred iterations of the algorithm, the true text is revealed. This post will explain the theory of how this works and will describe the computational details using R. Many of the details were inspired by an example given by Persi Diaconis in his paper “The Markov Chain Monte Carlo Revolution”<a href="#fn2" class="footnote-ref" id="fnref2" role="doc-noteref"><sup>2</sup></a>.</p><div class="no-row-height column-margin column-container"><li id="fn2"><p><sup>2</sup>&nbsp;<a href="https://math.uchicago.edu/~shmuel/Network-course-readings/MCMCRev.pdf" class="uri">https://math.uchicago.edu/~shmuel/Network-course-readings/MCMCRev.pdf</a></p></li></div></div>
</section><section id="the-substitution-cipher" class="level2 page-columns page-full"><h2 class="anchored" data-anchor-id="the-substitution-cipher">The substitution cipher</h2>
<p>The substitution cipher is one of the simplest cryptographic methods. It works by swapping each letter in the alphabet with another.</p>
<p>One simple type of substitution cipher is a shift cipher, where we shift the alphabet by a certain number of units. So a shift cipher with a shift of 3 would yield:</p>
<pre><code>Original Alpabet:  abcdefghijklmnopqrstuvwxyz
Cipher Alphabet:   defghijklmnopqrstuvwxyzabc</code></pre>
<p>With this cipher, the word <code>hello</code> would map to:</p>
<ul>
<li><code>h -&gt; k</code></li>
<li><code>e -&gt; h</code></li>
<li><code>l -&gt; o</code></li>
<li><code>l -&gt; o</code></li>
<li><code>o -&gt; r</code></li>
</ul>
<p>resulting in the ciphertext <code>khoor</code>.</p>
<div class="callout callout-style-default callout-note callout-titled">
<div class="callout-header d-flex align-content-center" data-bs-toggle="collapse" data-bs-target=".callout-1-contents" aria-controls="callout-1" aria-expanded="true" aria-label="Toggle callout">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Terminology
</div>
<div class="callout-btn-toggle d-inline-block border-0 py-1 ps-1 pe-0 float-end"><i class="callout-toggle"></i></div>
</div>
<div id="callout-1" class="callout-1-contents callout-collapse collapse show">
<div class="callout-body-container callout-body">
<p><strong>Plaintext</strong> refers to the text you input to the cipher (“hello”) and <strong>ciphertext</strong> refers to the output of the cipher (“khoor”).</p>
</div>
</div>
</div>
<p>We can do this in R using the built-in <code><a href="https://rdrr.io/r/base/chartr.html">chartr()</a></code> function, which encodes a given string from one alphabet to another.</p>
<div class="cell">
<div class="sourceCode" id="cb2"><pre class="downlit sourceCode r code-with-copy"><code class="sourceCode R"><span><span class="fu"><a href="https://rdrr.io/r/base/chartr.html">chartr</a></span><span class="op">(</span></span>
<span>  x <span class="op">=</span> <span class="st">"hello"</span>,</span>
<span>  old <span class="op">=</span> <span class="st">"abcdefghijklmnopqrstuvwxyz"</span>,</span>
<span>  new <span class="op">=</span> <span class="st">"defghijklmnopqrstuvwxyzabc"</span></span>
<span><span class="op">)</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>[1] "khoor"</code></pre>
</div>
</div>
<p>More generally, we can create an arbitrary substitution cipher by permuting the letters of the alphabet.</p>
<div class="page-columns page-full"><p></p><div class="no-row-height column-margin column-container"><span class=""><code>letters</code> is a built-in R object that contains the 26 letters of the English alphabet.</span></div></div>
<div class="page-columns page-full"><p></p><div class="no-row-height column-margin column-container"><span class=""><code>paste(collapse = "")</code> is used to turn a vector of characters into a single string.</span></div></div>
<div class="cell">
<div class="sourceCode" id="cb4"><pre class="downlit sourceCode r code-with-copy"><code class="sourceCode R"><span><span class="va">letters</span> <span class="op">|&gt;</span> <span class="fu"><a href="https://rdrr.io/r/base/paste.html">paste</a></span><span class="op">(</span>collapse <span class="op">=</span> <span class="st">""</span><span class="op">)</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>[1] "abcdefghijklmnopqrstuvwxyz"</code></pre>
</div>
</div>
<div class="cell">
<div class="sourceCode" id="cb6"><pre class="downlit sourceCode r code-with-copy"><code class="sourceCode R"><span><span class="fu"><a href="https://rdrr.io/r/base/sample.html">sample</a></span><span class="op">(</span><span class="va">letters</span><span class="op">)</span> <span class="op">|&gt;</span> <span class="fu"><a href="https://rdrr.io/r/base/paste.html">paste</a></span><span class="op">(</span>collapse <span class="op">=</span> <span class="st">""</span><span class="op">)</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>[1] "xasljwipdrvgfeuohbkmntzyqc"</code></pre>
</div>
</div>
<p>We can use the above code to create three functions which</p>
<ol type="1">
<li>Generate a random cipher</li>
<li>Encode plaintext with a given cipher</li>
<li>Decode ciphertext with a given cipher</li>
</ol>
<div class="cell">
<div class="sourceCode" id="cb8"><pre class="downlit sourceCode r code-with-copy"><code class="sourceCode R"><span><span class="co"># Generate a new cipher by permuting the letters of the alphabet</span></span>
<span><span class="va">generate_cipher</span> <span class="op">&lt;-</span> <span class="kw">function</span><span class="op">(</span><span class="op">)</span> <span class="fu"><a href="https://rdrr.io/r/base/sample.html">sample</a></span><span class="op">(</span><span class="va">letters</span>,</span>
<span>                                     replace <span class="op">=</span> <span class="cn">FALSE</span><span class="op">)</span></span>
<span></span>
<span><span class="co"># Encode a text using a cipher</span></span>
<span><span class="va">encode_text</span> <span class="op">&lt;-</span> <span class="kw">function</span><span class="op">(</span><span class="va">text</span>, <span class="va">cipher</span><span class="op">)</span> <span class="op">{</span></span>
<span>  <span class="fu"><a href="https://rdrr.io/r/base/chartr.html">chartr</a></span><span class="op">(</span></span>
<span>    x <span class="op">=</span> <span class="va">text</span>,</span>
<span>    old <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/paste.html">paste</a></span><span class="op">(</span><span class="va">letters</span>, collapse <span class="op">=</span> <span class="st">""</span><span class="op">)</span>,</span>
<span>    new <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/paste.html">paste</a></span><span class="op">(</span><span class="va">cipher</span>, collapse <span class="op">=</span> <span class="st">""</span><span class="op">)</span></span>
<span>  <span class="op">)</span></span>
<span><span class="op">}</span></span>
<span></span>
<span><span class="co"># Decode a text given a cipher</span></span>
<span><span class="va">decode_text</span> <span class="op">&lt;-</span> <span class="kw">function</span><span class="op">(</span><span class="va">ciphered_text</span>, <span class="va">cipher</span><span class="op">)</span> <span class="op">{</span></span>
<span>  <span class="fu"><a href="https://rdrr.io/r/base/chartr.html">chartr</a></span><span class="op">(</span></span>
<span>    x <span class="op">=</span> <span class="va">ciphered_text</span>,</span>
<span>    old <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/paste.html">paste</a></span><span class="op">(</span><span class="va">cipher</span>, collapse <span class="op">=</span> <span class="st">""</span><span class="op">)</span>,</span>
<span>    new <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/paste.html">paste</a></span><span class="op">(</span><span class="va">letters</span>, collapse <span class="op">=</span> <span class="st">""</span><span class="op">)</span></span>
<span>  <span class="op">)</span></span>
<span><span class="op">}</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Let’s test these functions to make sure they’re working correctly:</p>
<div class="cell">
<div class="sourceCode" id="cb9"><pre class="downlit sourceCode r code-with-copy"><code class="sourceCode R"><span><span class="va">plaintext</span> <span class="op">&lt;-</span> <span class="st">"to be or not to be that is the question whether tis nobler in the mind to suffer the slings and arrows of outrageous fortune or to take arms against a sea of troubles"</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="cell">
<div class="sourceCode" id="cb10"><pre class="downlit sourceCode r code-with-copy"><code class="sourceCode R"><span><span class="co"># Create and store the cipher</span></span>
<span><span class="va">true_cipher</span> <span class="op">&lt;-</span> <span class="fu">generate_cipher</span><span class="op">(</span><span class="op">)</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/base/print.html">print</a></span><span class="op">(</span><span class="va">true_cipher</span><span class="op">)</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code> [1] "w" "r" "j" "n" "p" "t" "a" "q" "k" "y" "l" "h" "b" "z" "u" "s" "i" "o" "e"
[20] "x" "f" "g" "v" "d" "m" "c"</code></pre>
</div>
</div>
<p>Here’s what the ciphertext looks like:</p>
<div class="cell">
<div class="sourceCode" id="cb12"><pre class="downlit sourceCode r code-with-copy"><code class="sourceCode R"><span><span class="co"># Encode the plaintext</span></span>
<span><span class="va">ciphertext</span> <span class="op">&lt;-</span> <span class="fu">encode_text</span><span class="op">(</span><span class="va">plaintext</span>, <span class="va">true_cipher</span><span class="op">)</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/base/print.html">print</a></span><span class="op">(</span><span class="va">ciphertext</span><span class="op">)</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>[1] "xu rp uo zux xu rp xqwx ke xqp ifpexkuz vqpxqpo xke zurhpo kz xqp bkzn xu efttpo xqp ehkzae wzn woouve ut ufxowapufe tuoxfzp uo xu xwlp wobe wawkzex w epw ut xoufrhpe"</code></pre>
</div>
</div>
<p>And we see that decoding it with the true cipher recovers the plaintext:</p>
<div class="cell">
<div class="sourceCode" id="cb14"><pre class="downlit sourceCode r code-with-copy"><code class="sourceCode R"><span><span class="co"># Decode the ciphertext</span></span>
<span><span class="va">decoded_text</span> <span class="op">&lt;-</span> <span class="fu">decode_text</span><span class="op">(</span><span class="va">ciphertext</span>, <span class="va">true_cipher</span><span class="op">)</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/base/print.html">print</a></span><span class="op">(</span><span class="va">decoded_text</span><span class="op">)</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>[1] "to be or not to be that is the question whether tis nobler in the mind to suffer the slings and arrows of outrageous fortune or to take arms against a sea of troubles"</code></pre>
</div>
</div>
</section><section id="overview-of-the-metropolis-algorithm" class="level2 page-columns page-full"><h2 class="anchored" data-anchor-id="overview-of-the-metropolis-algorithm">Overview of the Metropolis algorithm</h2>
<section id="why-not-use-brute-force" class="level3 page-columns page-full"><h3 class="anchored" data-anchor-id="why-not-use-brute-force">Why not use brute force?</h3>
<p>Suppose we intercept the ciphertext above, but we didn’t know the true cipher. How could we decode the hidden message?</p>
<p>A brute force idea would be to try all possible ciphers until we find the correct one. How long would that take? There are <span class="math inline">\(26!\)</span> ciphers to check because each cipher corresponds to a certain permutation of the alphabet.</p>
<div class="cell">
<div class="sourceCode" id="cb16"><pre class="downlit sourceCode r code-with-copy"><code class="sourceCode R"><span><span class="fu"><a href="https://rdrr.io/r/base/Special.html">factorial</a></span><span class="op">(</span><span class="fl">26</span><span class="op">)</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>[1] 4.032915e+26</code></pre>
</div>
</div>
<div class="page-columns page-full"><p>That’s a very big number! As a thought experiment, let’s assume that we have access to the fastest supercomputer in the world<a href="#fn3" class="footnote-ref" id="fnref3" role="doc-noteref"><sup>3</sup></a>. It’s reported that it can compute 1.1 quintillion operations (<span class="math inline">\(1.1 \times 10^{18}\)</span>) per second. Although checking a cipher would take more than a single operation, let’s assume that we can check a cipher in a single operation (since we are seeing if this approach is even feasible).</p><div class="no-row-height column-margin column-container"><li id="fn3"><p><sup>3</sup>&nbsp;<a href="https://arstechnica.com/information-technology/2022/05/1-1-quintillion-operations-per-second-us-has-worlds-fastest-supercomputer/" class="uri">https://arstechnica.com/information-technology/2022/05/1-1-quintillion-operations-per-second-us-has-worlds-fastest-supercomputer/</a></p></li></div></div>
<p><span class="math display">\[
(4.03 \times 10^{26}) \text{ ciphers} \times \left(\frac{1 \text{ second}}{1.1 \times 10^{18} \text{ciphers}}\right) \approx 366 \text{ million seconds} \approx 11.6 \text{ years}
\]</span></p>
<p>So even with the fastest computer in the world, and with some very generous assumptions about how many operations it takes to check a cipher, it would still take 11.6 years to test all of them. Let’s learn a much faster way to solve this problem. We don’t even need a supercomputer; a laptop will do just fine.</p>
</section><section id="the-metropolis-algorithm" class="level3 page-columns page-full"><h3 class="anchored" data-anchor-id="the-metropolis-algorithm">The Metropolis algorithm</h3>
<p>So, how can we beat the brute force method? The idea is to use an algorithm that seeks out the likely ciphers, and ignores the ciphers that are unlikely to be correct. This is what the Metropolis algorithm does.</p>
<div class="page-columns page-full"><p>The Metropolis algorithm is a Markov Chain Monte Carlo algorithm, which means that it is used to generate Markov Chains that converge to a desirable stationary distribution<a href="#fn4" class="footnote-ref" id="fnref4" role="doc-noteref"><sup>4</sup></a>. Markov chains are defined on a state space, where the chain is traveling from state to state. In the framework of our problem, the states our Markov Chain is traveling between are the <span class="math inline">\(26!\)</span> possible ciphers. We want to the Markov chain to travel to the ciphers that are more “likely to be correct” and stay away from the ciphers that are “unlikely to be correct”. While we will elaborate on this later, we can tentatively define “likely to be correct” ciphers as those that produce text that looks similar to English.</p><div class="no-row-height column-margin column-container"><li id="fn4"><p><sup>4</sup>&nbsp;For a review of Markov chains, see <a href="https://setosa.io/ev/markov-chains/" class="uri">https://setosa.io/ev/markov-chains/</a> and <a href="https://youtu.be/i3AkTO9HLXo" class="uri">https://youtu.be/i3AkTO9HLXo</a></p></li></div></div>
<p>Let <span class="math inline">\(\text{sim}(\text{cipher})\)</span> be a function that returns a score from 0 and 1 indicating how similar the text that a cipher produces is to English. With the <span class="math inline">\(\text{sim}(\text{cipher})\)</span> function defined, the Metropolis algorithm works like this. First, start with a randomly chosen cipher as the initial state. Then repeat the following steps until the code is cracked:</p>
<ol type="1">
<li>Choose a new (but closely related) cipher by swapping two letters in the current cipher at random. This is called the <strong>proposal cipher</strong>.</li>
<li>Compute the quantity <span class="math inline">\(\frac{\text{sim}(\text{proposal cipher})}{\text{sim}(\text{current cipher})}\)</span>. If the proposal cipher produces text more similar to English than the current cipher, this ratio will always be greater than 1. If the current cipher produces text more similar to English than the proposal cipher, this ratio will be between 0 and 1.</li>
<li>If the ratio in the previous step is greater than 1, set the current cipher to the proposed cipher. This is called <strong>accepting the proposal</strong>.</li>
<li>If the ratio is less than 1, accept the proposal with probability equal to <span class="math inline">\(\frac{\text{sim}(\text{proposal cipher})}{\text{sim}(\text{current cipher})}\)</span> and reject it (i.e., stay at the current cipher) with probability <span class="math inline">\(1 - \frac{\text{sim}(\text{proposal cipher})}{\text{sim}(\text{current cipher})}\)</span>.</li>
</ol>
<p>In other words, if the proposal cipher produces text more similar to English than the current cipher, we always accept it; and if the current cipher produces text more similar to English than the proposal cipher, we accept or reject it with probability given by the ratio of their scores. The worse a proposal performs, the less likely it will be accepted. The intuition behind this method is that it will travel towards ciphers that produce text more similar to English and ignore ciphers that don’t.</p>
<div class="callout callout-style-default callout-note callout-titled">
<div class="callout-header d-flex align-content-center" data-bs-toggle="collapse" data-bs-target=".callout-2-contents" aria-controls="callout-2" aria-expanded="true" aria-label="Toggle callout">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
The Metropolis algorithm and Bayesian statistics
</div>
<div class="callout-btn-toggle d-inline-block border-0 py-1 ps-1 pe-0 float-end"><i class="callout-toggle"></i></div>
</div>
<div id="callout-2" class="callout-2-contents callout-collapse collapse show">
<div class="callout-body-container callout-body">
<p>Technically, the Metropolis algorithm is designed to travel to states in proportion to the probability of each state. So by running the Metropolis algorithm on the space of ciphers, we are approximately sampling from the probability distribution of ciphers given the ciphertext, a concept that will be very familiar to those who use Bayesian statistics. Indeed, the Metropolis algorithm is used to perform Bayesian statistics in a variety of settings where an analytical approach is not feasible.</p>
<p>We are using the Metropolis algorithm here for optimization rather than sampling, a nice side-effect of the property that when sampling according to each state’s probability, high probability states are visited frequently.</p>
</div>
</div>
</div>
<p>To implement this algorithm, we need for formalize our notion of an “English-similarity score”. This will be the topic of the next section.</p>
</section></section><section id="defining-an-english-similarity-score" class="level2 page-columns page-full"><h2 class="anchored" data-anchor-id="defining-an-english-similarity-score">Defining an “English-similarity score”</h2>
<p>We need some way of measuring how similar to English an arbitrary text looks. Even a non-native speaker could likely tell that</p>
<div class="cell">
<div class="cell-output cell-output-stdout">
<pre><code>[1] "xu rp uo zux xu rp xqwx ke xqp ifpexkuz vqpxqpo xke zurhpo kz xqp bkzn xu efttpo xqp ehkzae wzn woouve ut ufxowapufe tuoxfzp uo xu xwlp wobe wawkzex w epw ut xoufrhpe"</code></pre>
</div>
</div>
<p>does not look like English. For example, most words don’t have any vowels!</p>
<p>A rough heuristic to see how similar a text is to English is to compute the two letter frequencies and see how similar they are to those in English. Here’s an example. <code>hello there</code> has the following 2-letter combinations: <code>"he" "el" "ll" "lo" "o " " t" "th" "he" "er" "re"</code>. You can picture this as a sliding window of width 2.</p>
<p>We could then compare how close the frequencies in this text align with the frequencies in English. Let <span class="math inline">\(\text{freq}(x)\)</span> be the frequency of two-letter combination <span class="math inline">\(x\)</span> in English (we’ll see how to compute this soon). Then the “English-similarity” score for <code>hello there</code> could be computed as <span class="math display">\[
\text{freq}(\text{he}) \times \text{freq}(\text{el}) \times \text{freq}(\text{ll}) \times \ldots \times \text{freq}(\text{re})
\]</span></p>
<section id="estimating-frequencies-based-on-a-sample-text" class="level3"><h3 class="anchored" data-anchor-id="estimating-frequencies-based-on-a-sample-text">Estimating frequencies based on a sample text</h3>
<p>Now let’s return to how we implement the <span class="math inline">\(\text{freq}(x)\)</span> function. An approximation to the two-letter frequencies in English could be to find a very long English text and use the frequencies within it. The text we’ll use to do this is <em>War and Peace</em> by Leo Tolstoy, a very long book by most standards. Luckily for us, <em>War and Peace</em> is in the public domain, and we can download a text file of the book from <a href="https://www.gutenberg.org/" class="uri">https://www.gutenberg.org/</a>.</p>
<div class="cell">
<div class="sourceCode" id="cb19"><pre class="downlit sourceCode r code-with-copy"><code class="sourceCode R"><span><span class="va">war_and_peace</span> <span class="op">&lt;-</span> <span class="fu">readr</span><span class="fu">::</span><span class="fu"><a href="https://readr.tidyverse.org/reference/read_file.html">read_file</a></span><span class="op">(</span><span class="st">"https://www.gutenberg.org/cache/epub/2600/pg2600.txt"</span><span class="op">)</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>We’ll clean the text a bit by:</p>
<ul>
<li>Converting all letters to lowercase</li>
<li>Removing all non-alphabetical characters (numbers, symbols, etc…) but keeping spaces</li>
<li>Removing all accent characters (like é)</li>
</ul>
<p>so that in the end, the text only contains the 26 lowercase letters and the space character.</p>
<div class="cell">
<div class="sourceCode" id="cb20"><pre class="downlit sourceCode r code-with-copy"><code class="sourceCode R"><span><span class="va">war_and_peace</span> <span class="op">&lt;-</span></span>
<span>  <span class="va">war_and_peace</span> <span class="op">|&gt;</span></span>
<span>  <span class="fu">stringr</span><span class="fu">::</span><span class="fu"><a href="https://stringr.tidyverse.org/reference/case.html">str_to_lower</a></span><span class="op">(</span><span class="op">)</span> <span class="op">|&gt;</span></span>
<span>  <span class="fu"><a href="https://rdrr.io/r/base/grep.html">gsub</a></span><span class="op">(</span>pattern <span class="op">=</span> <span class="st">"[^A-Za-z ]+"</span>, replacement <span class="op">=</span> <span class="st">""</span>, x<span class="op">=</span><span class="va">_</span><span class="op">)</span> <span class="op">|&gt;</span></span>
<span>  <span class="fu">stringi</span><span class="fu">::</span><span class="fu"><a href="https://rdrr.io/pkg/stringi/man/stri_trans_general.html">stri_trans_general</a></span><span class="op">(</span>id <span class="op">=</span> <span class="st">"Latin-ASCII"</span><span class="op">)</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</section><section id="obtaining-two-character-frequencies" class="level3"><h3 class="anchored" data-anchor-id="obtaining-two-character-frequencies">Obtaining two-character frequencies</h3>
<p>Now let’s design a function to break the text into two-character chunks. We can use the very fast <code><a href="https://rdrr.io/pkg/stringi/man/stri_sub.html">stringi::stri_sub()</a></code> function which, given a starting and ending index, extracts the substrings between them. Since our window has length two, we’ll offset the starting and ending indices by one.</p>
<p>We can test this approach on a short phrase to make sure it works.</p>
<div class="cell">
<div class="sourceCode" id="cb21"><pre class="downlit sourceCode r code-with-copy"><code class="sourceCode R"><span><span class="va">test_string</span> <span class="op">&lt;-</span> <span class="st">"hello there"</span></span>
<span></span>
<span><span class="va">starting_indices</span> <span class="op">&lt;-</span> <span class="fl">1</span> <span class="op">:</span> <span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/nchar.html">nchar</a></span><span class="op">(</span><span class="va">test_string</span><span class="op">)</span> <span class="op">-</span> <span class="fl">1</span><span class="op">)</span></span>
<span><span class="va">ending_indices</span> <span class="op">&lt;-</span> <span class="va">starting_indices</span> <span class="op">+</span> <span class="fl">1</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="cell">
<div class="sourceCode" id="cb22"><pre class="downlit sourceCode r code-with-copy"><code class="sourceCode R"><span><span class="va">starting_indices</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code> [1]  1  2  3  4  5  6  7  8  9 10</code></pre>
</div>
</div>
<div class="cell">
<div class="sourceCode" id="cb24"><pre class="downlit sourceCode r code-with-copy"><code class="sourceCode R"><span><span class="va">ending_indices</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code> [1]  2  3  4  5  6  7  8  9 10 11</code></pre>
</div>
</div>
<div class="cell">
<div class="sourceCode" id="cb26"><pre class="downlit sourceCode r code-with-copy"><code class="sourceCode R"><span><span class="fu">stringi</span><span class="fu">::</span><span class="fu"><a href="https://rdrr.io/pkg/stringi/man/stri_sub.html">stri_sub</a></span><span class="op">(</span><span class="va">test_string</span>,</span>
<span>                  from <span class="op">=</span> <span class="va">starting_indices</span>,</span>
<span>                  to <span class="op">=</span> <span class="va">ending_indices</span><span class="op">)</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code> [1] "he" "el" "ll" "lo" "o " " t" "th" "he" "er" "re"</code></pre>
</div>
</div>
<p>Now that we see our code works, let’s put it into a function.</p>
<div class="cell">
<div class="sourceCode" id="cb28"><pre class="downlit sourceCode r code-with-copy"><code class="sourceCode R"><span><span class="va">break_into_two_chars</span> <span class="op">&lt;-</span> <span class="kw">function</span><span class="op">(</span><span class="va">text</span><span class="op">)</span><span class="op">{</span></span>
<span>  <span class="va">starting_indices</span> <span class="op">&lt;-</span> <span class="fl">1</span> <span class="op">:</span> <span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/nchar.html">nchar</a></span><span class="op">(</span><span class="va">text</span><span class="op">)</span> <span class="op">-</span> <span class="fl">1</span><span class="op">)</span></span>
<span>  <span class="va">ending_indices</span> <span class="op">&lt;-</span> <span class="va">starting_indices</span> <span class="op">+</span> <span class="fl">1</span></span>
<span>  <span class="kw"><a href="https://rdrr.io/r/base/function.html">return</a></span><span class="op">(</span><span class="fu">stringi</span><span class="fu">::</span><span class="fu"><a href="https://rdrr.io/pkg/stringi/man/stri_sub.html">stri_sub</a></span><span class="op">(</span><span class="va">text</span>,</span>
<span>                           from <span class="op">=</span> <span class="va">starting_indices</span>,</span>
<span>                           to <span class="op">=</span> <span class="va">ending_indices</span><span class="op">)</span><span class="op">)</span></span>
<span><span class="op">}</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>We can now break <em>War and Peace</em> into two-character chunks.</p>
<div class="cell">
<div class="sourceCode" id="cb29"><pre class="downlit sourceCode r code-with-copy"><code class="sourceCode R"><span><span class="va">war_and_peace_2_characters</span> <span class="op">&lt;-</span> <span class="fu">break_into_two_chars</span><span class="op">(</span><span class="va">war_and_peace</span><span class="op">)</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="cell">
<div class="sourceCode" id="cb30"><pre class="downlit sourceCode r code-with-copy"><code class="sourceCode R"><span><span class="co"># Look at a piece of the results (skipping the table of contents)</span></span>
<span><span class="va">war_and_peace_2_characters</span><span class="op">[</span><span class="fl">10000</span><span class="op">:</span><span class="fl">10100</span><span class="op">]</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>  [1] "f " " a" "au" "us" "st" "tr" "ri" "ia" "a " " p" "pe" "er" "rh" "ha" "ap"
 [16] "ps" "s " " i" "i " " d" "do" "on" "nt" "t " " u" "un" "nd" "de" "er" "rs"
 [31] "st" "ta" "an" "nd" "dt" "th" "hi" "in" "ng" "gs" "s " " b" "bu" "ut" "t "
 [46] " a" "au" "us" "st" "tr" "ri" "ia" "a " " n" "ne" "ev" "ve" "er" "r " " h"
 [61] "ha" "as" "s " " w" "wi" "is" "sh" "he" "ed" "d " " a" "an" "nd" "d " " d"
 [76] "do" "oe" "es" "s " " n" "no" "ot" "t " " w" "wi" "is" "sh" "h " " f" "fo"
 [91] "or" "r " " w" "wa" "ar" "r " " s" "sh" "he" "ei" "is"</code></pre>
</div>
</div>
</section><section id="estimated-frequencies-from-war-and-peace" class="level3"><h3 class="anchored" data-anchor-id="estimated-frequencies-from-war-and-peace">Estimated frequencies from <em>War and Peace</em>
</h3>
<p>We can calculate the empirical probability of any two-letter combination by dividing the number of times it occurs by the total number of two-character chunks.</p>
<div class="cell">
<div class="sourceCode" id="cb32"><pre class="downlit sourceCode r code-with-copy"><code class="sourceCode R"><span><span class="co"># Ten most common two-character combinations</span></span>
<span><span class="va">probability_table</span> <span class="op">&lt;-</span></span>
<span>  <span class="fu"><a href="https://rdrr.io/r/base/table.html">table</a></span><span class="op">(</span><span class="va">war_and_peace_2_characters</span><span class="op">)</span> <span class="op">/</span> <span class="fu"><a href="https://rdrr.io/r/base/length.html">length</a></span><span class="op">(</span><span class="va">war_and_peace_2_characters</span><span class="op">)</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="cell">
<div class="sourceCode" id="cb33"><pre class="downlit sourceCode r code-with-copy"><code class="sourceCode R"><span><span class="fu"><a href="https://rdrr.io/r/utils/head.html">head</a></span><span class="op">(</span><span class="va">probability_table</span>, <span class="fl">40</span><span class="op">)</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>war_and_peace_2_characters
                        a            b            c            d            e 
9.053610e-04 2.097140e-02 7.463716e-03 6.200291e-03 5.077064e-03 3.436817e-03 
           f            g            h            i            j            k 
6.412562e-03 2.929341e-03 1.512555e-02 9.208617e-03 4.893754e-04 1.194642e-03 
           l            m            n            o            p            q 
3.989051e-03 5.850455e-03 4.422150e-03 1.038582e-02 5.434799e-03 4.205930e-04 
           r            s            t            u            v            w 
4.484022e-03 1.219292e-02 2.646478e-02 1.689283e-03 1.191351e-03 1.207313e-02 
           x            y            z           a            aa           ab 
1.474379e-04 1.931503e-03 4.179602e-05 4.516603e-03 2.369538e-05 1.161074e-03 
          ac           ad           ae           af           ag           ah 
2.347817e-03 3.736959e-03 2.501179e-05 5.660563e-04 1.129809e-03 1.260463e-04 
          ai           aj           ak           al 
2.882938e-03 5.759294e-05 8.388823e-04 4.695634e-03 </code></pre>
</div>
</div>
<p>Note that two-letter combinations that look like a single letter are actually a letter and a space, since we are including spaces in our frequencies to help the algorithm learn word boundaries.</p>
<p>Here are the 20 most common combinations.</p>
<div class="cell">
<div class="sourceCode" id="cb35"><pre class="downlit sourceCode r code-with-copy"><code class="sourceCode R"><span><span class="va">probability_table</span> <span class="op">|&gt;</span></span>
<span>  <span class="fu"><a href="https://rdrr.io/r/base/sort.html">sort</a></span><span class="op">(</span>decreasing <span class="op">=</span> <span class="cn">TRUE</span><span class="op">)</span> <span class="op">|&gt;</span></span>
<span>  <span class="fu"><a href="https://rdrr.io/r/utils/head.html">head</a></span><span class="op">(</span><span class="fl">20</span><span class="op">)</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>war_and_peace_2_characters
         e            t          he          th          d            a 
0.033159052 0.026464778 0.024673473 0.024416444 0.022819309 0.020971399 
         s           t           in           h          an          er 
0.018675251 0.017588225 0.015909144 0.015125551 0.014968898 0.014645720 
         n            s           w          re          nd           o 
0.012217272 0.012192919 0.012073125 0.011726251 0.011409326 0.010385817 
         ed          r  
0.009573263 0.009366257 </code></pre>
</div>
</div>
<p>We can also see the probability of any combination we choose:</p>
<div class="cell">
<div class="sourceCode" id="cb37"><pre class="downlit sourceCode r code-with-copy"><code class="sourceCode R"><span><span class="co"># Get the probability of "ou"</span></span>
<span><span class="va">probability_table</span><span class="op">[</span><span class="st">"ou"</span><span class="op">]</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>         ou 
0.007754971 </code></pre>
</div>
</div>
<p>However, there are some two-character combinations that do not occur in <em>War and Peace</em>. Instead of estimating the probability of these combinations to be zero, we instead approximate the probability by assuming each of them occurred once in the book. To implement this approximation, we use the below function, which returns the empirical probability of any two-character combination.</p>
<div class="cell">
<div class="sourceCode" id="cb39"><pre class="downlit sourceCode r code-with-copy"><code class="sourceCode R"><span><span class="va">get_prob_two_char</span> <span class="op">&lt;-</span> <span class="kw">function</span><span class="op">(</span><span class="va">two_char</span><span class="op">)</span><span class="op">{</span></span>
<span>  <span class="va">prob_from_table</span> <span class="op">&lt;-</span> <span class="va">probability_table</span><span class="op">[</span><span class="va">two_char</span><span class="op">]</span></span>
<span>  </span>
<span>  <span class="kw">if</span> <span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/NA.html">is.na</a></span><span class="op">(</span><span class="va">prob_from_table</span><span class="op">)</span><span class="op">)</span> <span class="op">{</span></span>
<span>    <span class="kw"><a href="https://rdrr.io/r/base/function.html">return</a></span><span class="op">(</span><span class="fl">1</span> <span class="op">/</span> <span class="fu"><a href="https://rdrr.io/r/base/length.html">length</a></span><span class="op">(</span><span class="va">war_and_peace_2_characters</span><span class="op">)</span><span class="op">)</span></span>
<span>  <span class="op">}</span> <span class="kw">else</span><span class="op">{</span></span>
<span>    <span class="kw"><a href="https://rdrr.io/r/base/function.html">return</a></span><span class="op">(</span><span class="va">prob_from_table</span><span class="op">)</span></span>
<span>  <span class="op">}</span></span>
<span><span class="op">}</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>We can try our function for a combination in <em>War and Peace</em> and a combination that is not:</p>
<div class="cell">
<div class="sourceCode" id="cb40"><pre class="downlit sourceCode r code-with-copy"><code class="sourceCode R"><span><span class="co"># Try a combination in War and Peace</span></span>
<span><span class="fu">get_prob_two_char</span><span class="op">(</span><span class="st">"ou"</span><span class="op">)</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>         ou 
0.007754971 </code></pre>
</div>
<div class="sourceCode" id="cb42"><pre class="downlit sourceCode r code-with-copy"><code class="sourceCode R"><span><span class="va">probability_table</span><span class="op">[</span><span class="st">"ou"</span><span class="op">]</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>         ou 
0.007754971 </code></pre>
</div>
<div class="sourceCode" id="cb44"><pre class="downlit sourceCode r code-with-copy"><code class="sourceCode R"><span><span class="co"># Try a combination not in War and Peace</span></span>
<span><span class="fu">get_prob_two_char</span><span class="op">(</span><span class="st">"qq"</span><span class="op">)</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>[1] 3.291025e-07</code></pre>
</div>
<div class="sourceCode" id="cb46"><pre class="downlit sourceCode r code-with-copy"><code class="sourceCode R"><span><span class="va">probability_table</span><span class="op">[</span><span class="st">"qq"</span><span class="op">]</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>&lt;NA&gt; 
  NA </code></pre>
</div>
</div>
</section><section id="getting-the-probability-of-a-new-text" class="level3 page-columns page-full"><h3 class="anchored" data-anchor-id="getting-the-probability-of-a-new-text">Getting the probability of a new text</h3>
<p>Now that we have a way to estimate the probability of any two character combination in English, we can use it to score how similar a given text is to English. A first approach, as described above, might be to break the new text into two character chunks, compute the probability of each, and multiply them together.</p>
<div class="page-columns page-full"><p></p><div class="no-row-height column-margin column-container"><span class=""><code>map_dbl()</code> is a function from the <code>purrr</code> package that iterates over each element of an input vector or list, and applies a function to each element. The <code>_dbl</code> in the function name means that the expected output is numeric. We need to use <code>map_dbl()</code> because our <code>get_prob_two_char()</code> function isn’t vectorized.</span></div></div>
<div class="cell">
<div class="sourceCode" id="cb48"><pre class="downlit sourceCode r code-with-copy"><code class="sourceCode R"><span><span class="va">sample_text</span> <span class="op">&lt;-</span> <span class="st">"this is a text"</span></span>
<span><span class="va">sample_text_two_char</span> <span class="op">&lt;-</span> <span class="fu">break_into_two_chars</span><span class="op">(</span><span class="va">sample_text</span><span class="op">)</span></span>
<span></span>
<span><span class="va">score</span> <span class="op">&lt;-</span> </span>
<span>  <span class="fu">purrr</span><span class="fu">::</span><span class="fu"><a href="https://purrr.tidyverse.org/reference/map.html">map_dbl</a></span><span class="op">(</span><span class="va">sample_text_two_char</span>, <span class="va">get_prob_two_char</span><span class="op">)</span> <span class="op">|&gt;</span></span>
<span>  <span class="fu"><a href="https://rdrr.io/r/base/prod.html">prod</a></span><span class="op">(</span><span class="op">)</span></span>
<span></span>
<span><span class="va">score</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>[1] 8.63621e-29</code></pre>
</div>
</div>
<p>However, we see that the score is an extremely small number, about <span class="math inline">\(10^{-55}\)</span>. Therefore, for better numerical precision, we should work on the log scale, and then transform back when we need probabilities. Remember, on the log scale we express products as sums. Below is a function to implement this approach:</p>
<ol type="1">
<li>Break the text into two character chunks</li>
<li>Compute the probability of each chunk using our representative English text (<em>War and Peace</em>)</li>
<li>Take the log of each probability</li>
<li>Sum the probabilities to get a log-likelihood for the text</li>
</ol>
<div class="cell">
<div class="sourceCode" id="cb50"><pre class="downlit sourceCode r code-with-copy"><code class="sourceCode R"><span><span class="va">get_log_lik_text</span> <span class="op">&lt;-</span> <span class="kw">function</span><span class="op">(</span><span class="va">text</span><span class="op">)</span><span class="op">{</span></span>
<span>  <span class="va">text</span> <span class="op">|&gt;</span></span>
<span>  <span class="fu">break_into_two_chars</span><span class="op">(</span><span class="op">)</span> <span class="op">|&gt;</span></span>
<span>  <span class="fu">purrr</span><span class="fu">::</span><span class="fu"><a href="https://purrr.tidyverse.org/reference/map.html">map_dbl</a></span><span class="op">(</span><span class="va">get_prob_two_char</span><span class="op">)</span> <span class="op">|&gt;</span></span>
<span>  <span class="fu"><a href="https://rdrr.io/r/base/Log.html">log</a></span><span class="op">(</span><span class="op">)</span> <span class="op">|&gt;</span></span>
<span>  <span class="fu"><a href="https://rdrr.io/r/base/sum.html">sum</a></span><span class="op">(</span><span class="op">)</span></span>
<span><span class="op">}</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Let’s see if our score can differentiate English and non-English: a comparison of English words with me hitting random keys.</p>
<div class="cell">
<div class="sourceCode" id="cb51"><pre class="downlit sourceCode r code-with-copy"><code class="sourceCode R"><span><span class="fu">get_log_lik_text</span><span class="op">(</span><span class="st">"This is English text"</span><span class="op">)</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>[1] -130.5349</code></pre>
</div>
<div class="sourceCode" id="cb53"><pre class="downlit sourceCode r code-with-copy"><code class="sourceCode R"><span><span class="fu">get_log_lik_text</span><span class="op">(</span><span class="st">"fghr gh wghdfrf etfs"</span><span class="op">)</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>[1] -139.0768</code></pre>
</div>
</div>
<p>As expected the log-likelihood for the English text is higher than for the non-English text.</p>
</section></section><section id="implementing-the-metropolis-algorithm" class="level2 page-columns page-full"><h2 class="anchored" data-anchor-id="implementing-the-metropolis-algorithm">Implementing the Metropolis Algorithm</h2>
<p>Now we are finally ready to implement our code-breaking algorithm! One helper function we need is a function to swap two elements of a vector. As discussed above, we’ll use this to propose a new cipher given the current cipher.</p>
<div class="cell">
<div class="sourceCode" id="cb55"><pre class="downlit sourceCode r code-with-copy"><code class="sourceCode R"><span><span class="va">swap</span> <span class="op">&lt;-</span> <span class="kw">function</span><span class="op">(</span><span class="va">x</span><span class="op">)</span><span class="op">{</span></span>
<span>  <span class="co"># Select two distinct indices</span></span>
<span>  <span class="va">rand_indices</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/sample.html">sample</a></span><span class="op">(</span><span class="fl">1</span><span class="op">:</span><span class="fu"><a href="https://rdrr.io/r/base/length.html">length</a></span><span class="op">(</span><span class="va">x</span><span class="op">)</span>, size <span class="op">=</span> <span class="fl">2</span>, replace<span class="op">=</span><span class="cn">FALSE</span><span class="op">)</span></span>
<span>  <span class="va">element_1</span> <span class="op">&lt;-</span> <span class="va">x</span><span class="op">[</span><span class="va">rand_indices</span><span class="op">[</span><span class="fl">1</span><span class="op">]</span><span class="op">]</span></span>
<span>  <span class="va">element_2</span> <span class="op">&lt;-</span> <span class="va">x</span><span class="op">[</span><span class="va">rand_indices</span><span class="op">[</span><span class="fl">2</span><span class="op">]</span><span class="op">]</span></span>
<span>  </span>
<span>  <span class="va">x</span><span class="op">[</span><span class="va">rand_indices</span><span class="op">[</span><span class="fl">1</span><span class="op">]</span><span class="op">]</span> <span class="op">&lt;-</span> <span class="va">element_2</span></span>
<span>  <span class="va">x</span><span class="op">[</span><span class="va">rand_indices</span><span class="op">[</span><span class="fl">2</span><span class="op">]</span><span class="op">]</span> <span class="op">&lt;-</span> <span class="va">element_1</span></span>
<span>  </span>
<span>  <span class="kw"><a href="https://rdrr.io/r/base/function.html">return</a></span><span class="op">(</span><span class="va">x</span><span class="op">)</span></span>
<span><span class="op">}</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Below is the full algorithm, the same one I ran to create the video at the beginning of this post. The steps correspond to the description I gave above for the Metropolis algorithm, now substituting in the functions we created. I have added detailed comments for each line of the code. Try running it for yourself and use your own example text.</p>
<p>A few tips:</p>
<ul>
<li>The algorithm may take many iterations to converge, sometimes close to 20,000, although this is highly dependent on the cipher chosen and the starting cipher.</li>
<li>Since this is a relatively short text, it may take more iterations to decode. Long texts contain more information, and so are more easily decoded.</li>
<li>If the chain doesn’t seem to be converging, try a new random seed. I had to try a few random seeds for the algorithm to converge in a reasonable number of iterations<a href="#fn5" class="footnote-ref" id="fnref5" role="doc-noteref"><sup>5</sup></a>.</li>
</ul>
<div class="no-row-height column-margin column-container"><li id="fn5"><p><sup>5</sup>&nbsp;While this strategy of restarting misbehaving Markov chains isn’t a good strategy for other applications of MCMC like Bayesian statistics, it’s perfectly reasonable for the optimization task we are performing here.</p></li></div><div class="cell">
<div class="sourceCode" id="cb56"><pre class="downlit sourceCode r code-with-copy"><code class="sourceCode R"><span><span class="va">plaintext</span> <span class="op">&lt;-</span> <span class="st">"to be or not to be that is the question whether tis nobler in the mind to suffer the slings and arrows of outrageous fortune or to take arms against a sea of troubles"</span></span>
<span></span>
<span><span class="co"># Generate a random cipher to be the true cipher</span></span>
<span><span class="va">true_cipher</span> <span class="op">&lt;-</span> <span class="fu">generate_cipher</span><span class="op">(</span><span class="op">)</span></span>
<span></span>
<span><span class="co"># Encode the plaintext</span></span>
<span><span class="va">ciphered_text</span> <span class="op">&lt;-</span> <span class="fu">encode_text</span><span class="op">(</span>text <span class="op">=</span> <span class="va">plaintext</span>,</span>
<span>                             cipher <span class="op">=</span> <span class="va">true_cipher</span><span class="op">)</span></span>
<span></span>
<span><span class="co"># Create another random cipher to be the starting cipher for the Markov Chain</span></span>
<span><span class="va">current_cipher</span> <span class="op">&lt;-</span> <span class="fu">generate_cipher</span><span class="op">(</span><span class="op">)</span></span>
<span></span>
<span><span class="co"># A counter to track how many decoded texts have been accepted</span></span>
<span><span class="va">i</span> <span class="op">&lt;-</span> <span class="fl">0</span></span>
<span></span>
<span><span class="kw">for</span> <span class="op">(</span><span class="va">iter</span> <span class="kw">in</span> <span class="fl">1</span><span class="op">:</span><span class="fl">50000</span><span class="op">)</span> <span class="op">{</span></span>
<span>  </span>
<span>  <span class="co"># Propose a new cipher by swapping two letters in the current cipher</span></span>
<span>  <span class="va">proposed_cipher</span> <span class="op">&lt;-</span> <span class="fu">swap</span><span class="op">(</span><span class="va">current_cipher</span><span class="op">)</span></span>
<span>  </span>
<span>  <span class="co"># Text decoded from the proposal cipher</span></span>
<span>  <span class="va">decoded_text_proposed</span> <span class="op">&lt;-</span> <span class="fu">decode_text</span><span class="op">(</span><span class="va">ciphered_text</span>,</span>
<span>                              cipher <span class="op">=</span> <span class="va">proposed_cipher</span><span class="op">)</span></span>
<span>  </span>
<span>  <span class="co"># Text decoded from the current cipher</span></span>
<span>  <span class="va">decoded_text_current</span> <span class="op">&lt;-</span> <span class="fu">decode_text</span><span class="op">(</span><span class="va">ciphered_text</span>,</span>
<span>                              cipher <span class="op">=</span> <span class="va">current_cipher</span><span class="op">)</span></span>
<span>  </span>
<span>  <span class="co"># Log-likelihood of the decoded text from the proposal cipher</span></span>
<span>  <span class="va">proposed_log_lik</span> <span class="op">&lt;-</span> <span class="fu">get_log_lik_text</span><span class="op">(</span><span class="va">decoded_text_proposed</span><span class="op">)</span></span>
<span>  </span>
<span>  <span class="co"># Log-likelihood of the decoded text from the current cipher</span></span>
<span>  <span class="va">current_log_lik</span> <span class="op">&lt;-</span> <span class="fu">get_log_lik_text</span><span class="op">(</span><span class="va">decoded_text_current</span><span class="op">)</span></span>
<span>  </span>
<span>  <span class="co"># Acceptance probability of the proposal, defined by the Metropolis algorithm</span></span>
<span>  <span class="co"># Remember that subtraction on the log-scale is division on the probability</span></span>
<span>  <span class="co"># scale. We exponentiate to get back to the probability scale.</span></span>
<span>  <span class="va">acceptance_probability</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/Extremes.html">min</a></span><span class="op">(</span><span class="fl">1</span>, <span class="fu"><a href="https://rdrr.io/r/base/Log.html">exp</a></span><span class="op">(</span><span class="va">proposed_log_lik</span> <span class="op">-</span> <span class="va">current_log_lik</span><span class="op">)</span><span class="op">)</span></span>
<span>  </span>
<span>  <span class="co"># Accept or not with probability given by `acceptance_probability`</span></span>
<span>  <span class="va">accept</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/sample.html">sample</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="cn">TRUE</span>, <span class="cn">FALSE</span><span class="op">)</span>,</span>
<span>                   size<span class="op">=</span><span class="fl">1</span>,</span>
<span>                   prob <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="va">acceptance_probability</span>,</span>
<span>                            <span class="fl">1</span><span class="op">-</span><span class="va">acceptance_probability</span><span class="op">)</span><span class="op">)</span></span>
<span>  </span>
<span>  <span class="co"># IF we accept the proposal, set the proposal cipher as the current cipher</span></span>
<span>  <span class="co"># ELSE, go on to the next iteration</span></span>
<span>  <span class="kw">if</span> <span class="op">(</span><span class="va">accept</span><span class="op">)</span> <span class="op">{</span></span>
<span>    <span class="va">current_cipher</span> <span class="op">&lt;-</span> <span class="va">proposed_cipher</span></span>
<span>    </span>
<span>    <span class="co"># Print the text as decoded by the current cipher</span></span>
<span>    <span class="fu"><a href="https://rdrr.io/r/base/print.html">print</a></span><span class="op">(</span><span class="fu">glue</span><span class="fu">::</span><span class="fu"><a href="https://glue.tidyverse.org/reference/glue.html">glue</a></span><span class="op">(</span><span class="st">"Iteration {i}: {decoded_text_proposed}"</span><span class="op">)</span><span class="op">)</span></span>
<span>    </span>
<span>    <span class="co"># Increment the counter so that we can keep track of acceptances</span></span>
<span>    <span class="co"># This is just for printing the output</span></span>
<span>    <span class="va">i</span> <span class="op">&lt;-</span> <span class="va">i</span> <span class="op">+</span> <span class="fl">1</span></span>
<span>  <span class="op">}</span></span>
<span><span class="op">}</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>For clarity, here’s the same code without comments.</p>
<div class="cell">
<div class="sourceCode" id="cb57"><pre class="downlit sourceCode r code-with-copy"><code class="sourceCode R"><span><span class="va">plaintext</span> <span class="op">&lt;-</span> <span class="st">"to be or not to be that is the question whether tis nobler in the mind to suffer the slings and arrows of outrageous fortune or to take arms against a sea of troubles"</span></span>
<span></span>
<span><span class="va">true_cipher</span> <span class="op">&lt;-</span> <span class="fu">generate_cipher</span><span class="op">(</span><span class="op">)</span></span>
<span><span class="va">ciphered_text</span> <span class="op">&lt;-</span> <span class="fu">encode_text</span><span class="op">(</span>text <span class="op">=</span> <span class="va">plaintext</span>,</span>
<span>                             cipher <span class="op">=</span> <span class="va">true_cipher</span><span class="op">)</span></span>
<span></span>
<span><span class="va">current_cipher</span> <span class="op">&lt;-</span> <span class="fu">generate_cipher</span><span class="op">(</span><span class="op">)</span></span>
<span></span>
<span><span class="va">i</span> <span class="op">&lt;-</span> <span class="fl">0</span></span>
<span></span>
<span><span class="kw">for</span> <span class="op">(</span><span class="va">iter</span> <span class="kw">in</span> <span class="fl">1</span><span class="op">:</span><span class="fl">50000</span><span class="op">)</span> <span class="op">{</span></span>
<span>  </span>
<span>  <span class="va">proposed_cipher</span> <span class="op">&lt;-</span> <span class="fu">swap</span><span class="op">(</span><span class="va">current_cipher</span><span class="op">)</span></span>
<span>  </span>
<span>  <span class="va">decoded_text_proposed</span> <span class="op">&lt;-</span> <span class="fu">decode_text</span><span class="op">(</span><span class="va">ciphered_text</span>,</span>
<span>                              cipher <span class="op">=</span> <span class="va">proposed_cipher</span><span class="op">)</span></span>
<span>  <span class="va">decoded_text_current</span> <span class="op">&lt;-</span> <span class="fu">decode_text</span><span class="op">(</span><span class="va">ciphered_text</span>,</span>
<span>                              cipher <span class="op">=</span> <span class="va">current_cipher</span><span class="op">)</span></span>
<span>  </span>
<span>  <span class="va">proposed_log_lik</span> <span class="op">&lt;-</span> <span class="fu">get_log_lik_text</span><span class="op">(</span><span class="va">decoded_text_proposed</span><span class="op">)</span></span>
<span>  <span class="va">current_log_lik</span> <span class="op">&lt;-</span> <span class="fu">get_log_lik_text</span><span class="op">(</span><span class="va">decoded_text_current</span><span class="op">)</span></span>
<span>  </span>
<span>  <span class="va">acceptance_probability</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/Extremes.html">min</a></span><span class="op">(</span><span class="fl">1</span>, <span class="fu"><a href="https://rdrr.io/r/base/Log.html">exp</a></span><span class="op">(</span><span class="va">proposed_log_lik</span> <span class="op">-</span> <span class="va">current_log_lik</span><span class="op">)</span><span class="op">)</span></span>
<span>  </span>
<span>  <span class="va">accept</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/sample.html">sample</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="cn">TRUE</span>, <span class="cn">FALSE</span><span class="op">)</span>,</span>
<span>                   size<span class="op">=</span><span class="fl">1</span>,</span>
<span>                   prob <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="va">acceptance_probability</span>,</span>
<span>                            <span class="fl">1</span><span class="op">-</span><span class="va">acceptance_probability</span><span class="op">)</span><span class="op">)</span></span>
<span>  </span>
<span>  <span class="kw">if</span> <span class="op">(</span><span class="va">accept</span><span class="op">)</span> <span class="op">{</span></span>
<span>    <span class="va">current_cipher</span> <span class="op">&lt;-</span> <span class="va">proposed_cipher</span></span>
<span>    <span class="fu"><a href="https://rdrr.io/r/base/print.html">print</a></span><span class="op">(</span><span class="fu">glue</span><span class="fu">::</span><span class="fu"><a href="https://glue.tidyverse.org/reference/glue.html">glue</a></span><span class="op">(</span><span class="st">"Iteration {i}: {decoded_text_proposed}"</span><span class="op">)</span><span class="op">)</span></span>
<span>    <span class="va">i</span> <span class="op">&lt;-</span> <span class="va">i</span> <span class="op">+</span> <span class="fl">1</span></span>
<span>  <span class="op">}</span></span>
<span><span class="op">}</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>


<!-- -->

</section></main><!-- /main --><script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    text: function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
  const viewSource = window.document.getElementById('quarto-view-source') ||
                     window.document.getElementById('quarto-code-tools-source');
  if (viewSource) {
    const sourceUrl = viewSource.getAttribute("data-quarto-source-url");
    viewSource.addEventListener("click", function(e) {
      if (sourceUrl) {
        // rstudio viewer pane
        if (/\bcapabilities=\b/.test(window.location)) {
          window.open(sourceUrl);
        } else {
          window.location.href = sourceUrl;
        }
      } else {
        const modal = new bootstrap.Modal(document.getElementById('quarto-embedded-source-code-modal'));
        modal.show();
      }
      return false;
    });
  }
  function toggleCodeHandler(show) {
    return function(e) {
      const detailsSrc = window.document.querySelectorAll(".cell > details > .sourceCode");
      for (let i=0; i<detailsSrc.length; i++) {
        const details = detailsSrc[i].parentElement;
        if (show) {
          details.open = true;
        } else {
          details.removeAttribute("open");
        }
      }
      const cellCodeDivs = window.document.querySelectorAll(".cell > .sourceCode");
      const fromCls = show ? "hidden" : "unhidden";
      const toCls = show ? "unhidden" : "hidden";
      for (let i=0; i<cellCodeDivs.length; i++) {
        const codeDiv = cellCodeDivs[i];
        if (codeDiv.classList.contains(fromCls)) {
          codeDiv.classList.remove(fromCls);
          codeDiv.classList.add(toCls);
        } 
      }
      return false;
    }
  }
  const hideAllCode = window.document.getElementById("quarto-hide-all-code");
  if (hideAllCode) {
    hideAllCode.addEventListener("click", toggleCodeHandler(false));
  }
  const showAllCode = window.document.getElementById("quarto-show-all-code");
  if (showAllCode) {
    showAllCode.addEventListener("click", toggleCodeHandler(true));
  }
  function tippyHover(el, contentFn) {
    const config = {
      allowHTML: true,
      content: contentFn,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start'
    };
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      return note.innerHTML;
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script><script src="https://utteranc.es/client.js" repo="maxdrohde/blog_quarto" issue-term="pathname" theme="github-light" crossorigin="anonymous" async="">
</script><div class="modal fade" id="quarto-embedded-source-code-modal" tabindex="-1" aria-labelledby="quarto-embedded-source-code-modal-label" aria-hidden="true"><div class="modal-dialog modal-dialog-scrollable"><div class="modal-content"><div class="modal-header"><h5 class="modal-title" id="quarto-embedded-source-code-modal-label">Source Code</h5><button class="btn-close" data-bs-dismiss="modal"></button></div><div class="modal-body"><div class="">
<div class="sourceCode" id="cb58" data-shortcodes="false"><pre class="sourceCode markdown code-with-copy"><code class="sourceCode markdown"><span id="cb58-1"><a href="#cb58-1" aria-hidden="true" tabindex="-1"></a><span class="co">---</span></span>
<span id="cb58-2"><a href="#cb58-2" aria-hidden="true" tabindex="-1"></a><span class="an">title:</span><span class="co"> Code-breaking with Markov Chain Monte Carlo (MCMC)</span></span>
<span id="cb58-3"><a href="#cb58-3" aria-hidden="true" tabindex="-1"></a><span class="an">description:</span><span class="co"> Using cryptography to demonstrate the power of MCMC techniques in computational statistics</span></span>
<span id="cb58-4"><a href="#cb58-4" aria-hidden="true" tabindex="-1"></a><span class="an">author:</span><span class="co"> Max Rohde</span></span>
<span id="cb58-5"><a href="#cb58-5" aria-hidden="true" tabindex="-1"></a><span class="an">date:</span><span class="co"> 11/10/2022</span></span>
<span id="cb58-6"><a href="#cb58-6" aria-hidden="true" tabindex="-1"></a><span class="an">image:</span><span class="co"> preview.png</span></span>
<span id="cb58-7"><a href="#cb58-7" aria-hidden="true" tabindex="-1"></a><span class="an">code-fold:</span><span class="co"> false</span></span>
<span id="cb58-8"><a href="#cb58-8" aria-hidden="true" tabindex="-1"></a><span class="co">---</span></span>
<span id="cb58-9"><a href="#cb58-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb58-12"><a href="#cb58-12" aria-hidden="true" tabindex="-1"></a><span class="in">```{r}</span></span>
<span id="cb58-13"><a href="#cb58-13" aria-hidden="true" tabindex="-1"></a><span class="co">#| include: false</span></span>
<span id="cb58-14"><a href="#cb58-14" aria-hidden="true" tabindex="-1"></a><span class="fu">set.seed</span>(<span class="dv">777</span>)</span>
<span id="cb58-15"><a href="#cb58-15" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb58-16"><a href="#cb58-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb58-17"><a href="#cb58-17" aria-hidden="true" tabindex="-1"></a><span class="fu">## Overview</span></span>
<span id="cb58-18"><a href="#cb58-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb58-19"><a href="#cb58-19" aria-hidden="true" tabindex="-1"></a>In this post we will show how a common method in computational statistics, Markov Chain Monte Carlo (implemented using the Metropolis algorithm), can be used to decode hidden messages encoded using a substitution cipher^<span class="co">[</span><span class="ot">From Merriam-Webster, a cipher is defined as "a method of transforming a text in order to conceal its meaning".</span><span class="co">]</span>.</span>
<span id="cb58-20"><a href="#cb58-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb58-21"><a href="#cb58-21" aria-hidden="true" tabindex="-1"></a>To cut to the chase, here's a video of the algorithm in action running on my laptop:</span>
<span id="cb58-22"><a href="#cb58-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb58-23"><a href="#cb58-23" aria-hidden="true" tabindex="-1"></a><span class="al">![](demo.mp4)</span>{fig-width=100%}</span>
<span id="cb58-24"><a href="#cb58-24" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb58-25"><a href="#cb58-25" aria-hidden="true" tabindex="-1"></a>We see that within a few hundred iterations of the algorithm, the true text is revealed. This post will explain the theory of how this works and will describe the computational details using R. Many of the details were inspired by an example given by Persi Diaconis in his paper "The Markov Chain Monte Carlo Revolution"^<span class="co">[</span><span class="ot">&lt;https://math.uchicago.edu/~shmuel/Network-course-readings/MCMCRev.pdf&gt;</span><span class="co">]</span>.</span>
<span id="cb58-26"><a href="#cb58-26" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb58-27"><a href="#cb58-27" aria-hidden="true" tabindex="-1"></a><span class="fu">## The substitution cipher</span></span>
<span id="cb58-28"><a href="#cb58-28" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb58-29"><a href="#cb58-29" aria-hidden="true" tabindex="-1"></a>The substitution cipher is one of the simplest cryptographic methods. It works by swapping each letter in the alphabet with another.</span>
<span id="cb58-30"><a href="#cb58-30" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb58-31"><a href="#cb58-31" aria-hidden="true" tabindex="-1"></a>One simple type of substitution cipher is a shift cipher, where we shift the alphabet by a certain number of units. So a shift cipher with a shift of 3 would yield:</span>
<span id="cb58-32"><a href="#cb58-32" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb58-33"><a href="#cb58-33" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb58-34"><a href="#cb58-34" aria-hidden="true" tabindex="-1"></a><span class="in">Original Alpabet:  abcdefghijklmnopqrstuvwxyz</span></span>
<span id="cb58-35"><a href="#cb58-35" aria-hidden="true" tabindex="-1"></a><span class="in">Cipher Alphabet:   defghijklmnopqrstuvwxyzabc</span></span>
<span id="cb58-36"><a href="#cb58-36" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb58-37"><a href="#cb58-37" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb58-38"><a href="#cb58-38" aria-hidden="true" tabindex="-1"></a>With this cipher, the word <span class="in">`hello`</span> would map to:</span>
<span id="cb58-39"><a href="#cb58-39" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb58-40"><a href="#cb58-40" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span><span class="in">`h -&gt; k`</span></span>
<span id="cb58-41"><a href="#cb58-41" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span><span class="in">`e -&gt; h`</span></span>
<span id="cb58-42"><a href="#cb58-42" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span><span class="in">`l -&gt; o`</span></span>
<span id="cb58-43"><a href="#cb58-43" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span><span class="in">`l -&gt; o`</span></span>
<span id="cb58-44"><a href="#cb58-44" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span><span class="in">`o -&gt; r`</span></span>
<span id="cb58-45"><a href="#cb58-45" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb58-46"><a href="#cb58-46" aria-hidden="true" tabindex="-1"></a>resulting in the ciphertext <span class="in">`khoor`</span>.</span>
<span id="cb58-47"><a href="#cb58-47" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb58-48"><a href="#cb58-48" aria-hidden="true" tabindex="-1"></a>:::{.callout-note collapse="false"}</span>
<span id="cb58-49"><a href="#cb58-49" aria-hidden="true" tabindex="-1"></a><span class="fu">## Terminology</span></span>
<span id="cb58-50"><a href="#cb58-50" aria-hidden="true" tabindex="-1"></a>**Plaintext** refers to the text you input to the cipher ("hello") and **ciphertext** refers to the output of the cipher ("khoor").</span>
<span id="cb58-51"><a href="#cb58-51" aria-hidden="true" tabindex="-1"></a>:::</span>
<span id="cb58-52"><a href="#cb58-52" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb58-53"><a href="#cb58-53" aria-hidden="true" tabindex="-1"></a>We can do this in R using the built-in <span class="in">`chartr()`</span> function, which encodes a given string from one alphabet to another.</span>
<span id="cb58-54"><a href="#cb58-54" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb58-57"><a href="#cb58-57" aria-hidden="true" tabindex="-1"></a><span class="in">```{r}</span></span>
<span id="cb58-58"><a href="#cb58-58" aria-hidden="true" tabindex="-1"></a><span class="fu">chartr</span>(</span>
<span id="cb58-59"><a href="#cb58-59" aria-hidden="true" tabindex="-1"></a>  <span class="at">x =</span> <span class="st">"hello"</span>,</span>
<span id="cb58-60"><a href="#cb58-60" aria-hidden="true" tabindex="-1"></a>  <span class="at">old =</span> <span class="st">"abcdefghijklmnopqrstuvwxyz"</span>,</span>
<span id="cb58-61"><a href="#cb58-61" aria-hidden="true" tabindex="-1"></a>  <span class="at">new =</span> <span class="st">"defghijklmnopqrstuvwxyzabc"</span></span>
<span id="cb58-62"><a href="#cb58-62" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb58-63"><a href="#cb58-63" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb58-64"><a href="#cb58-64" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb58-65"><a href="#cb58-65" aria-hidden="true" tabindex="-1"></a>More generally, we can create an arbitrary substitution cipher by permuting the letters of the alphabet.</span>
<span id="cb58-66"><a href="#cb58-66" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb58-67"><a href="#cb58-67" aria-hidden="true" tabindex="-1"></a><span class="co">[</span><span class="ot">`letters` is a built-in R object that contains the 26 letters of the English alphabet.</span><span class="co">]</span>{.aside}</span>
<span id="cb58-68"><a href="#cb58-68" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb58-69"><a href="#cb58-69" aria-hidden="true" tabindex="-1"></a><span class="co">[</span><span class="ot">`paste(collapse = "")` is used to turn a vector of characters into a single string.</span><span class="co">]</span>{.aside}</span>
<span id="cb58-70"><a href="#cb58-70" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb58-73"><a href="#cb58-73" aria-hidden="true" tabindex="-1"></a><span class="in">```{r}</span></span>
<span id="cb58-74"><a href="#cb58-74" aria-hidden="true" tabindex="-1"></a>letters <span class="sc">|&gt;</span> <span class="fu">paste</span>(<span class="at">collapse =</span> <span class="st">""</span>)</span>
<span id="cb58-75"><a href="#cb58-75" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb58-78"><a href="#cb58-78" aria-hidden="true" tabindex="-1"></a><span class="in">```{r}</span></span>
<span id="cb58-79"><a href="#cb58-79" aria-hidden="true" tabindex="-1"></a><span class="fu">sample</span>(letters) <span class="sc">|&gt;</span> <span class="fu">paste</span>(<span class="at">collapse =</span> <span class="st">""</span>)</span>
<span id="cb58-80"><a href="#cb58-80" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb58-81"><a href="#cb58-81" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb58-82"><a href="#cb58-82" aria-hidden="true" tabindex="-1"></a>We can use the above code to create three functions which</span>
<span id="cb58-83"><a href="#cb58-83" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb58-84"><a href="#cb58-84" aria-hidden="true" tabindex="-1"></a>1) Generate a random cipher</span>
<span id="cb58-85"><a href="#cb58-85" aria-hidden="true" tabindex="-1"></a>2) Encode plaintext with a given cipher</span>
<span id="cb58-86"><a href="#cb58-86" aria-hidden="true" tabindex="-1"></a>3) Decode ciphertext with a given cipher</span>
<span id="cb58-87"><a href="#cb58-87" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb58-90"><a href="#cb58-90" aria-hidden="true" tabindex="-1"></a><span class="in">```{r}</span></span>
<span id="cb58-91"><a href="#cb58-91" aria-hidden="true" tabindex="-1"></a><span class="co"># Generate a new cipher by permuting the letters of the alphabet</span></span>
<span id="cb58-92"><a href="#cb58-92" aria-hidden="true" tabindex="-1"></a>generate_cipher <span class="ot">&lt;-</span> <span class="cf">function</span>() <span class="fu">sample</span>(letters,</span>
<span id="cb58-93"><a href="#cb58-93" aria-hidden="true" tabindex="-1"></a>                                     <span class="at">replace =</span> <span class="cn">FALSE</span>)</span>
<span id="cb58-94"><a href="#cb58-94" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb58-95"><a href="#cb58-95" aria-hidden="true" tabindex="-1"></a><span class="co"># Encode a text using a cipher</span></span>
<span id="cb58-96"><a href="#cb58-96" aria-hidden="true" tabindex="-1"></a>encode_text <span class="ot">&lt;-</span> <span class="cf">function</span>(text, cipher) {</span>
<span id="cb58-97"><a href="#cb58-97" aria-hidden="true" tabindex="-1"></a>  <span class="fu">chartr</span>(</span>
<span id="cb58-98"><a href="#cb58-98" aria-hidden="true" tabindex="-1"></a>    <span class="at">x =</span> text,</span>
<span id="cb58-99"><a href="#cb58-99" aria-hidden="true" tabindex="-1"></a>    <span class="at">old =</span> <span class="fu">paste</span>(letters, <span class="at">collapse =</span> <span class="st">""</span>),</span>
<span id="cb58-100"><a href="#cb58-100" aria-hidden="true" tabindex="-1"></a>    <span class="at">new =</span> <span class="fu">paste</span>(cipher, <span class="at">collapse =</span> <span class="st">""</span>)</span>
<span id="cb58-101"><a href="#cb58-101" aria-hidden="true" tabindex="-1"></a>  )</span>
<span id="cb58-102"><a href="#cb58-102" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb58-103"><a href="#cb58-103" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb58-104"><a href="#cb58-104" aria-hidden="true" tabindex="-1"></a><span class="co"># Decode a text given a cipher</span></span>
<span id="cb58-105"><a href="#cb58-105" aria-hidden="true" tabindex="-1"></a>decode_text <span class="ot">&lt;-</span> <span class="cf">function</span>(ciphered_text, cipher) {</span>
<span id="cb58-106"><a href="#cb58-106" aria-hidden="true" tabindex="-1"></a>  <span class="fu">chartr</span>(</span>
<span id="cb58-107"><a href="#cb58-107" aria-hidden="true" tabindex="-1"></a>    <span class="at">x =</span> ciphered_text,</span>
<span id="cb58-108"><a href="#cb58-108" aria-hidden="true" tabindex="-1"></a>    <span class="at">old =</span> <span class="fu">paste</span>(cipher, <span class="at">collapse =</span> <span class="st">""</span>),</span>
<span id="cb58-109"><a href="#cb58-109" aria-hidden="true" tabindex="-1"></a>    <span class="at">new =</span> <span class="fu">paste</span>(letters, <span class="at">collapse =</span> <span class="st">""</span>)</span>
<span id="cb58-110"><a href="#cb58-110" aria-hidden="true" tabindex="-1"></a>  )</span>
<span id="cb58-111"><a href="#cb58-111" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb58-112"><a href="#cb58-112" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb58-113"><a href="#cb58-113" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb58-114"><a href="#cb58-114" aria-hidden="true" tabindex="-1"></a>Let's test these functions to make sure they're working correctly:</span>
<span id="cb58-115"><a href="#cb58-115" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb58-118"><a href="#cb58-118" aria-hidden="true" tabindex="-1"></a><span class="in">```{r}</span></span>
<span id="cb58-119"><a href="#cb58-119" aria-hidden="true" tabindex="-1"></a>plaintext <span class="ot">&lt;-</span> <span class="st">"to be or not to be that is the question whether tis nobler in the mind to suffer the slings and arrows of outrageous fortune or to take arms against a sea of troubles"</span></span>
<span id="cb58-120"><a href="#cb58-120" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb58-121"><a href="#cb58-121" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb58-124"><a href="#cb58-124" aria-hidden="true" tabindex="-1"></a><span class="in">```{r}</span></span>
<span id="cb58-125"><a href="#cb58-125" aria-hidden="true" tabindex="-1"></a><span class="co"># Create and store the cipher</span></span>
<span id="cb58-126"><a href="#cb58-126" aria-hidden="true" tabindex="-1"></a>true_cipher <span class="ot">&lt;-</span> <span class="fu">generate_cipher</span>()</span>
<span id="cb58-127"><a href="#cb58-127" aria-hidden="true" tabindex="-1"></a><span class="fu">print</span>(true_cipher)</span>
<span id="cb58-128"><a href="#cb58-128" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb58-129"><a href="#cb58-129" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb58-130"><a href="#cb58-130" aria-hidden="true" tabindex="-1"></a>Here's what the ciphertext looks like:</span>
<span id="cb58-131"><a href="#cb58-131" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb58-134"><a href="#cb58-134" aria-hidden="true" tabindex="-1"></a><span class="in">```{r}</span></span>
<span id="cb58-135"><a href="#cb58-135" aria-hidden="true" tabindex="-1"></a><span class="co"># Encode the plaintext</span></span>
<span id="cb58-136"><a href="#cb58-136" aria-hidden="true" tabindex="-1"></a>ciphertext <span class="ot">&lt;-</span> <span class="fu">encode_text</span>(plaintext, true_cipher)</span>
<span id="cb58-137"><a href="#cb58-137" aria-hidden="true" tabindex="-1"></a><span class="fu">print</span>(ciphertext)</span>
<span id="cb58-138"><a href="#cb58-138" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb58-139"><a href="#cb58-139" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb58-140"><a href="#cb58-140" aria-hidden="true" tabindex="-1"></a>And we see that decoding it with the true cipher recovers the plaintext:</span>
<span id="cb58-141"><a href="#cb58-141" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb58-144"><a href="#cb58-144" aria-hidden="true" tabindex="-1"></a><span class="in">```{r}</span></span>
<span id="cb58-145"><a href="#cb58-145" aria-hidden="true" tabindex="-1"></a><span class="co"># Decode the ciphertext</span></span>
<span id="cb58-146"><a href="#cb58-146" aria-hidden="true" tabindex="-1"></a>decoded_text <span class="ot">&lt;-</span> <span class="fu">decode_text</span>(ciphertext, true_cipher)</span>
<span id="cb58-147"><a href="#cb58-147" aria-hidden="true" tabindex="-1"></a><span class="fu">print</span>(decoded_text)</span>
<span id="cb58-148"><a href="#cb58-148" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb58-149"><a href="#cb58-149" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb58-150"><a href="#cb58-150" aria-hidden="true" tabindex="-1"></a><span class="fu">## Overview of the Metropolis algorithm</span></span>
<span id="cb58-151"><a href="#cb58-151" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb58-152"><a href="#cb58-152" aria-hidden="true" tabindex="-1"></a><span class="fu">### Why not use brute force?</span></span>
<span id="cb58-153"><a href="#cb58-153" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb58-154"><a href="#cb58-154" aria-hidden="true" tabindex="-1"></a>Suppose we intercept the ciphertext above, but we didn't know the true cipher. How could we decode the hidden message?</span>
<span id="cb58-155"><a href="#cb58-155" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb58-156"><a href="#cb58-156" aria-hidden="true" tabindex="-1"></a>A brute force idea would be to try all possible ciphers until we find the correct one. How long would that take? There are $26!$ ciphers to check because each cipher corresponds to a certain permutation of the alphabet.</span>
<span id="cb58-157"><a href="#cb58-157" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb58-160"><a href="#cb58-160" aria-hidden="true" tabindex="-1"></a><span class="in">```{r}</span></span>
<span id="cb58-161"><a href="#cb58-161" aria-hidden="true" tabindex="-1"></a><span class="fu">factorial</span>(<span class="dv">26</span>)</span>
<span id="cb58-162"><a href="#cb58-162" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb58-163"><a href="#cb58-163" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb58-164"><a href="#cb58-164" aria-hidden="true" tabindex="-1"></a>That's a very big number! As a thought experiment, let's assume that we have access to the fastest supercomputer in the world^<span class="co">[</span><span class="ot">&lt;https://arstechnica.com/information-technology/2022/05/1-1-quintillion-operations-per-second-us-has-worlds-fastest-supercomputer/&gt;</span><span class="co">]</span>. It's reported that it can compute 1.1 quintillion operations ($1.1 \times 10^{18}$) per second. Although checking a cipher would take more than a single operation, let's assume that we can check a cipher in a single operation (since we are seeing if this approach is even feasible).</span>
<span id="cb58-165"><a href="#cb58-165" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb58-168"><a href="#cb58-168" aria-hidden="true" tabindex="-1"></a><span class="in">```{r}</span></span>
<span id="cb58-169"><a href="#cb58-169" aria-hidden="true" tabindex="-1"></a><span class="co">#| include: false</span></span>
<span id="cb58-170"><a href="#cb58-170" aria-hidden="true" tabindex="-1"></a><span class="fu">factorial</span>(<span class="dv">26</span>) <span class="sc">/</span> (<span class="fl">1.1</span> <span class="sc">*</span> <span class="dv">10</span><span class="sc">^</span><span class="dv">18</span>)</span>
<span id="cb58-171"><a href="#cb58-171" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb58-172"><a href="#cb58-172" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb58-173"><a href="#cb58-173" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb58-174"><a href="#cb58-174" aria-hidden="true" tabindex="-1"></a>(4.03 \times 10^{26}) \text{ ciphers} \times \left(\frac{1 \text{ second}}{1.1 \times 10^{18} \text{ciphers}}\right) \approx 366 \text{ million seconds} \approx 11.6 \text{ years} </span>
<span id="cb58-175"><a href="#cb58-175" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb58-176"><a href="#cb58-176" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb58-177"><a href="#cb58-177" aria-hidden="true" tabindex="-1"></a>So even with the fastest computer in the world, and with some very generous assumptions about how many operations it takes to check a cipher, it would still take 11.6 years to test all of them. Let's learn a much faster way to solve this problem. We don't even need a supercomputer; a laptop will do just fine.</span>
<span id="cb58-178"><a href="#cb58-178" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb58-179"><a href="#cb58-179" aria-hidden="true" tabindex="-1"></a><span class="fu">### The Metropolis algorithm</span></span>
<span id="cb58-180"><a href="#cb58-180" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb58-181"><a href="#cb58-181" aria-hidden="true" tabindex="-1"></a>So, how can we beat the brute force method? The idea is to use an algorithm that seeks out the likely ciphers, and ignores the ciphers that are unlikely to be correct. This is what the Metropolis algorithm does.</span>
<span id="cb58-182"><a href="#cb58-182" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb58-183"><a href="#cb58-183" aria-hidden="true" tabindex="-1"></a>The Metropolis algorithm is a Markov Chain Monte Carlo algorithm, which means that it is used to generate Markov Chains that converge to a desirable stationary distribution^<span class="co">[</span><span class="ot">For a review of Markov chains, see &lt;https://setosa.io/ev/markov-chains/&gt; and &lt;https://youtu.be/i3AkTO9HLXo&gt;</span><span class="co">]</span>. Markov chains are defined on a state space, where the chain is traveling from state to state. In the framework of our problem, the states our Markov Chain is traveling between are the $26!$ possible ciphers. We want to the Markov chain to travel to the ciphers that are more "likely to be correct" and stay away from the ciphers that are "unlikely to be correct". While we will elaborate on this later, we can tentatively define "likely to be correct" ciphers as those that produce text that looks similar to English.</span>
<span id="cb58-184"><a href="#cb58-184" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb58-185"><a href="#cb58-185" aria-hidden="true" tabindex="-1"></a>Let $\text{sim}(\text{cipher})$ be a function that returns a score from 0 and 1 indicating how similar the text that a cipher produces is to English. With the $\text{sim}(\text{cipher})$ function defined, the Metropolis algorithm works like this. First, start with a randomly chosen cipher as the initial state. Then repeat the following steps until the code is cracked:</span>
<span id="cb58-186"><a href="#cb58-186" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb58-187"><a href="#cb58-187" aria-hidden="true" tabindex="-1"></a>1) Choose a new (but closely related) cipher by swapping two letters in the current cipher at random. This is called the **proposal cipher**.</span>
<span id="cb58-188"><a href="#cb58-188" aria-hidden="true" tabindex="-1"></a>2) Compute the quantity $\frac{\text{sim}(\text{proposal cipher})}{\text{sim}(\text{current cipher})}$. If the proposal cipher produces text more similar to English than the current cipher, this ratio will always be greater than 1. If the current cipher produces text more similar to English than the proposal cipher, this ratio will be between 0 and 1.</span>
<span id="cb58-189"><a href="#cb58-189" aria-hidden="true" tabindex="-1"></a>3) If the ratio in the previous step is greater than 1, set the current cipher to the proposed cipher. This is called **accepting the proposal**.</span>
<span id="cb58-190"><a href="#cb58-190" aria-hidden="true" tabindex="-1"></a>4) If the ratio is less than 1, accept the proposal with probability equal to $\frac{\text{sim}(\text{proposal cipher})}{\text{sim}(\text{current cipher})}$ and reject it (i.e., stay at the current cipher) with probability $1 - \frac{\text{sim}(\text{proposal cipher})}{\text{sim}(\text{current cipher})}$.</span>
<span id="cb58-191"><a href="#cb58-191" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb58-192"><a href="#cb58-192" aria-hidden="true" tabindex="-1"></a>In other words, if the proposal cipher produces text more similar to English than the current cipher, we always accept it; and if the current cipher produces text more similar to English than the proposal cipher, we accept or reject it with probability given by the ratio of their scores. The worse a proposal performs, the less likely it will be accepted. The intuition behind this method is that it will travel towards ciphers that produce text more similar to English and ignore ciphers that don't.</span>
<span id="cb58-193"><a href="#cb58-193" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb58-194"><a href="#cb58-194" aria-hidden="true" tabindex="-1"></a>:::{.callout-note collapse="false"}</span>
<span id="cb58-195"><a href="#cb58-195" aria-hidden="true" tabindex="-1"></a><span class="fu">## The Metropolis algorithm and Bayesian statistics</span></span>
<span id="cb58-196"><a href="#cb58-196" aria-hidden="true" tabindex="-1"></a>Technically, the Metropolis algorithm is designed to travel to states in proportion to the probability of each state. So by running the Metropolis algorithm on the space of ciphers, we are approximately sampling from the probability distribution of ciphers given the ciphertext, a concept that will be very familiar to those who use Bayesian statistics. Indeed, the Metropolis algorithm is used to perform Bayesian statistics in a variety of settings where an analytical approach is not feasible.</span>
<span id="cb58-197"><a href="#cb58-197" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb58-198"><a href="#cb58-198" aria-hidden="true" tabindex="-1"></a>We are using the Metropolis algorithm here for optimization rather than sampling, a nice side-effect of the property that when sampling according to each state's probability, high probability states are visited frequently.</span>
<span id="cb58-199"><a href="#cb58-199" aria-hidden="true" tabindex="-1"></a>:::</span>
<span id="cb58-200"><a href="#cb58-200" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb58-201"><a href="#cb58-201" aria-hidden="true" tabindex="-1"></a>To implement this algorithm, we need for formalize our notion of an "English-similarity score". This will be the topic of the next section.</span>
<span id="cb58-202"><a href="#cb58-202" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb58-203"><a href="#cb58-203" aria-hidden="true" tabindex="-1"></a><span class="fu">## Defining an "English-similarity score"</span></span>
<span id="cb58-204"><a href="#cb58-204" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb58-205"><a href="#cb58-205" aria-hidden="true" tabindex="-1"></a>We need some way of measuring how similar to English an arbitrary text looks. Even a non-native speaker could likely tell that</span>
<span id="cb58-206"><a href="#cb58-206" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb58-209"><a href="#cb58-209" aria-hidden="true" tabindex="-1"></a><span class="in">```{r}</span></span>
<span id="cb58-210"><a href="#cb58-210" aria-hidden="true" tabindex="-1"></a><span class="co">#| echo: false</span></span>
<span id="cb58-211"><a href="#cb58-211" aria-hidden="true" tabindex="-1"></a>ciphertext</span>
<span id="cb58-212"><a href="#cb58-212" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb58-213"><a href="#cb58-213" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb58-214"><a href="#cb58-214" aria-hidden="true" tabindex="-1"></a>does not look like English. For example, most words don't have any vowels!</span>
<span id="cb58-215"><a href="#cb58-215" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb58-216"><a href="#cb58-216" aria-hidden="true" tabindex="-1"></a>A rough heuristic to see how similar a text is to English is to compute the two letter frequencies and see how similar they are to those in English. Here's an example. <span class="in">`hello there`</span> has the following 2-letter combinations: <span class="in">`"he" "el" "ll" "lo" "o " " t" "th" "he" "er" "re"`</span>. You can picture this as a sliding window of width 2.</span>
<span id="cb58-217"><a href="#cb58-217" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb58-218"><a href="#cb58-218" aria-hidden="true" tabindex="-1"></a>We could then compare how close the frequencies in this text align with the frequencies in English. Let $\text{freq}(x)$ be the frequency of two-letter combination $x$ in English (we'll see how to compute this soon). Then the "English-similarity" score for <span class="in">`hello there`</span> could be computed as</span>
<span id="cb58-219"><a href="#cb58-219" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb58-220"><a href="#cb58-220" aria-hidden="true" tabindex="-1"></a>\text{freq}(\text{he}) \times \text{freq}(\text{el}) \times \text{freq}(\text{ll}) \times \ldots \times \text{freq}(\text{re})</span>
<span id="cb58-221"><a href="#cb58-221" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb58-222"><a href="#cb58-222" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb58-223"><a href="#cb58-223" aria-hidden="true" tabindex="-1"></a><span class="fu">### Estimating frequencies based on a sample text</span></span>
<span id="cb58-224"><a href="#cb58-224" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb58-225"><a href="#cb58-225" aria-hidden="true" tabindex="-1"></a>Now let's return to how we implement the $\text{freq}(x)$ function. An approximation to the two-letter frequencies in English could be to find a very long English text and use the frequencies within it. The text we'll use to do this is *War and Peace* by Leo Tolstoy, a very long book by most standards. Luckily for us, *War and Peace* is in the public domain, and we can download a text file of the book from <span class="ot">&lt;https://www.gutenberg.org/&gt;</span>.</span>
<span id="cb58-226"><a href="#cb58-226" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb58-229"><a href="#cb58-229" aria-hidden="true" tabindex="-1"></a><span class="in">```{r}</span></span>
<span id="cb58-230"><a href="#cb58-230" aria-hidden="true" tabindex="-1"></a>war_and_peace <span class="ot">&lt;-</span> readr<span class="sc">::</span><span class="fu">read_file</span>(<span class="st">"https://www.gutenberg.org/cache/epub/2600/pg2600.txt"</span>)</span>
<span id="cb58-231"><a href="#cb58-231" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb58-232"><a href="#cb58-232" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb58-233"><a href="#cb58-233" aria-hidden="true" tabindex="-1"></a>We'll clean the text a bit by:</span>
<span id="cb58-234"><a href="#cb58-234" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb58-235"><a href="#cb58-235" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>Converting all letters to lowercase</span>
<span id="cb58-236"><a href="#cb58-236" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>Removing all non-alphabetical characters (numbers, symbols, etc...) but keeping spaces</span>
<span id="cb58-237"><a href="#cb58-237" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>Removing all accent characters (like é)</span>
<span id="cb58-238"><a href="#cb58-238" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb58-239"><a href="#cb58-239" aria-hidden="true" tabindex="-1"></a>so that in the end, the text only contains the 26 lowercase letters and the space character.</span>
<span id="cb58-240"><a href="#cb58-240" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb58-243"><a href="#cb58-243" aria-hidden="true" tabindex="-1"></a><span class="in">```{r}</span></span>
<span id="cb58-244"><a href="#cb58-244" aria-hidden="true" tabindex="-1"></a>war_and_peace <span class="ot">&lt;-</span></span>
<span id="cb58-245"><a href="#cb58-245" aria-hidden="true" tabindex="-1"></a>  war_and_peace <span class="sc">|&gt;</span></span>
<span id="cb58-246"><a href="#cb58-246" aria-hidden="true" tabindex="-1"></a>  stringr<span class="sc">::</span><span class="fu">str_to_lower</span>() <span class="sc">|&gt;</span></span>
<span id="cb58-247"><a href="#cb58-247" aria-hidden="true" tabindex="-1"></a>  <span class="fu">gsub</span>(<span class="at">pattern =</span> <span class="st">"[^A-Za-z ]+"</span>, <span class="at">replacement =</span> <span class="st">""</span>, <span class="at">x=</span>_) <span class="sc">|&gt;</span></span>
<span id="cb58-248"><a href="#cb58-248" aria-hidden="true" tabindex="-1"></a>  stringi<span class="sc">::</span><span class="fu">stri_trans_general</span>(<span class="at">id =</span> <span class="st">"Latin-ASCII"</span>)</span>
<span id="cb58-249"><a href="#cb58-249" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb58-250"><a href="#cb58-250" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb58-251"><a href="#cb58-251" aria-hidden="true" tabindex="-1"></a><span class="fu">### Obtaining two-character frequencies</span></span>
<span id="cb58-252"><a href="#cb58-252" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb58-253"><a href="#cb58-253" aria-hidden="true" tabindex="-1"></a>Now let's design a function to break the text into two-character chunks. We can use the very fast <span class="in">`stringi::stri_sub()`</span> function which, given a starting and ending index, extracts the substrings between them. Since our window has length two, we'll offset the starting and ending indices by one.</span>
<span id="cb58-254"><a href="#cb58-254" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb58-255"><a href="#cb58-255" aria-hidden="true" tabindex="-1"></a>We can test this approach on a short phrase to make sure it works.</span>
<span id="cb58-256"><a href="#cb58-256" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb58-259"><a href="#cb58-259" aria-hidden="true" tabindex="-1"></a><span class="in">```{r}</span></span>
<span id="cb58-260"><a href="#cb58-260" aria-hidden="true" tabindex="-1"></a>test_string <span class="ot">&lt;-</span> <span class="st">"hello there"</span></span>
<span id="cb58-261"><a href="#cb58-261" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb58-262"><a href="#cb58-262" aria-hidden="true" tabindex="-1"></a>starting_indices <span class="ot">&lt;-</span> <span class="dv">1</span> <span class="sc">:</span> (<span class="fu">nchar</span>(test_string) <span class="sc">-</span> <span class="dv">1</span>)</span>
<span id="cb58-263"><a href="#cb58-263" aria-hidden="true" tabindex="-1"></a>ending_indices <span class="ot">&lt;-</span> starting_indices <span class="sc">+</span> <span class="dv">1</span></span>
<span id="cb58-264"><a href="#cb58-264" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb58-265"><a href="#cb58-265" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb58-268"><a href="#cb58-268" aria-hidden="true" tabindex="-1"></a><span class="in">```{r}</span></span>
<span id="cb58-269"><a href="#cb58-269" aria-hidden="true" tabindex="-1"></a>starting_indices</span>
<span id="cb58-270"><a href="#cb58-270" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb58-271"><a href="#cb58-271" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb58-274"><a href="#cb58-274" aria-hidden="true" tabindex="-1"></a><span class="in">```{r}</span></span>
<span id="cb58-275"><a href="#cb58-275" aria-hidden="true" tabindex="-1"></a>ending_indices</span>
<span id="cb58-276"><a href="#cb58-276" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb58-277"><a href="#cb58-277" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb58-280"><a href="#cb58-280" aria-hidden="true" tabindex="-1"></a><span class="in">```{r}</span></span>
<span id="cb58-281"><a href="#cb58-281" aria-hidden="true" tabindex="-1"></a>stringi<span class="sc">::</span><span class="fu">stri_sub</span>(test_string,</span>
<span id="cb58-282"><a href="#cb58-282" aria-hidden="true" tabindex="-1"></a>                  <span class="at">from =</span> starting_indices,</span>
<span id="cb58-283"><a href="#cb58-283" aria-hidden="true" tabindex="-1"></a>                  <span class="at">to =</span> ending_indices)</span>
<span id="cb58-284"><a href="#cb58-284" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb58-285"><a href="#cb58-285" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb58-286"><a href="#cb58-286" aria-hidden="true" tabindex="-1"></a>Now that we see our code works, let's put it into a function.</span>
<span id="cb58-287"><a href="#cb58-287" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb58-290"><a href="#cb58-290" aria-hidden="true" tabindex="-1"></a><span class="in">```{r}</span></span>
<span id="cb58-291"><a href="#cb58-291" aria-hidden="true" tabindex="-1"></a>break_into_two_chars <span class="ot">&lt;-</span> <span class="cf">function</span>(text){</span>
<span id="cb58-292"><a href="#cb58-292" aria-hidden="true" tabindex="-1"></a>  starting_indices <span class="ot">&lt;-</span> <span class="dv">1</span> <span class="sc">:</span> (<span class="fu">nchar</span>(text) <span class="sc">-</span> <span class="dv">1</span>)</span>
<span id="cb58-293"><a href="#cb58-293" aria-hidden="true" tabindex="-1"></a>  ending_indices <span class="ot">&lt;-</span> starting_indices <span class="sc">+</span> <span class="dv">1</span></span>
<span id="cb58-294"><a href="#cb58-294" aria-hidden="true" tabindex="-1"></a>  <span class="fu">return</span>(stringi<span class="sc">::</span><span class="fu">stri_sub</span>(text,</span>
<span id="cb58-295"><a href="#cb58-295" aria-hidden="true" tabindex="-1"></a>                           <span class="at">from =</span> starting_indices,</span>
<span id="cb58-296"><a href="#cb58-296" aria-hidden="true" tabindex="-1"></a>                           <span class="at">to =</span> ending_indices))</span>
<span id="cb58-297"><a href="#cb58-297" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb58-298"><a href="#cb58-298" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb58-299"><a href="#cb58-299" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb58-300"><a href="#cb58-300" aria-hidden="true" tabindex="-1"></a>We can now break *War and Peace* into two-character chunks.</span>
<span id="cb58-301"><a href="#cb58-301" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb58-304"><a href="#cb58-304" aria-hidden="true" tabindex="-1"></a><span class="in">```{r}</span></span>
<span id="cb58-305"><a href="#cb58-305" aria-hidden="true" tabindex="-1"></a>war_and_peace_2_characters <span class="ot">&lt;-</span> <span class="fu">break_into_two_chars</span>(war_and_peace)</span>
<span id="cb58-306"><a href="#cb58-306" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb58-307"><a href="#cb58-307" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb58-310"><a href="#cb58-310" aria-hidden="true" tabindex="-1"></a><span class="in">```{r}</span></span>
<span id="cb58-311"><a href="#cb58-311" aria-hidden="true" tabindex="-1"></a><span class="co"># Look at a piece of the results (skipping the table of contents)</span></span>
<span id="cb58-312"><a href="#cb58-312" aria-hidden="true" tabindex="-1"></a>war_and_peace_2_characters[<span class="dv">10000</span><span class="sc">:</span><span class="dv">10100</span>]</span>
<span id="cb58-313"><a href="#cb58-313" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb58-314"><a href="#cb58-314" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb58-315"><a href="#cb58-315" aria-hidden="true" tabindex="-1"></a><span class="fu">### Estimated frequencies from *War and Peace*</span></span>
<span id="cb58-316"><a href="#cb58-316" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb58-317"><a href="#cb58-317" aria-hidden="true" tabindex="-1"></a>We can calculate the empirical probability of any two-letter combination by dividing the number of times it occurs by the total number of two-character chunks.</span>
<span id="cb58-318"><a href="#cb58-318" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb58-321"><a href="#cb58-321" aria-hidden="true" tabindex="-1"></a><span class="in">```{r}</span></span>
<span id="cb58-322"><a href="#cb58-322" aria-hidden="true" tabindex="-1"></a><span class="co"># Ten most common two-character combinations</span></span>
<span id="cb58-323"><a href="#cb58-323" aria-hidden="true" tabindex="-1"></a>probability_table <span class="ot">&lt;-</span></span>
<span id="cb58-324"><a href="#cb58-324" aria-hidden="true" tabindex="-1"></a>  <span class="fu">table</span>(war_and_peace_2_characters) <span class="sc">/</span> <span class="fu">length</span>(war_and_peace_2_characters)</span>
<span id="cb58-325"><a href="#cb58-325" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb58-326"><a href="#cb58-326" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb58-329"><a href="#cb58-329" aria-hidden="true" tabindex="-1"></a><span class="in">```{r}</span></span>
<span id="cb58-330"><a href="#cb58-330" aria-hidden="true" tabindex="-1"></a><span class="fu">head</span>(probability_table, <span class="dv">40</span>)</span>
<span id="cb58-331"><a href="#cb58-331" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb58-332"><a href="#cb58-332" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb58-333"><a href="#cb58-333" aria-hidden="true" tabindex="-1"></a>Note that two-letter combinations that look like a single letter are actually a letter and a space, since we are including spaces in our frequencies to help the algorithm learn word boundaries.</span>
<span id="cb58-334"><a href="#cb58-334" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb58-335"><a href="#cb58-335" aria-hidden="true" tabindex="-1"></a>Here are the 20 most common combinations.</span>
<span id="cb58-336"><a href="#cb58-336" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb58-339"><a href="#cb58-339" aria-hidden="true" tabindex="-1"></a><span class="in">```{r}</span></span>
<span id="cb58-340"><a href="#cb58-340" aria-hidden="true" tabindex="-1"></a>probability_table <span class="sc">|&gt;</span></span>
<span id="cb58-341"><a href="#cb58-341" aria-hidden="true" tabindex="-1"></a>  <span class="fu">sort</span>(<span class="at">decreasing =</span> <span class="cn">TRUE</span>) <span class="sc">|&gt;</span></span>
<span id="cb58-342"><a href="#cb58-342" aria-hidden="true" tabindex="-1"></a>  <span class="fu">head</span>(<span class="dv">20</span>)</span>
<span id="cb58-343"><a href="#cb58-343" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb58-344"><a href="#cb58-344" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb58-345"><a href="#cb58-345" aria-hidden="true" tabindex="-1"></a>We can also see the probability of any combination we choose:</span>
<span id="cb58-346"><a href="#cb58-346" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb58-349"><a href="#cb58-349" aria-hidden="true" tabindex="-1"></a><span class="in">```{r}</span></span>
<span id="cb58-350"><a href="#cb58-350" aria-hidden="true" tabindex="-1"></a><span class="co"># Get the probability of "ou"</span></span>
<span id="cb58-351"><a href="#cb58-351" aria-hidden="true" tabindex="-1"></a>probability_table[<span class="st">"ou"</span>]</span>
<span id="cb58-352"><a href="#cb58-352" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb58-353"><a href="#cb58-353" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb58-354"><a href="#cb58-354" aria-hidden="true" tabindex="-1"></a>However, there are some two-character combinations that do not occur in *War and Peace*. Instead of estimating the probability of these combinations to be zero, we instead approximate the probability by assuming each of them occurred once in the book. To implement this approximation, we use the below function, which returns the empirical probability of any two-character combination.</span>
<span id="cb58-355"><a href="#cb58-355" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb58-358"><a href="#cb58-358" aria-hidden="true" tabindex="-1"></a><span class="in">```{r}</span></span>
<span id="cb58-359"><a href="#cb58-359" aria-hidden="true" tabindex="-1"></a>get_prob_two_char <span class="ot">&lt;-</span> <span class="cf">function</span>(two_char){</span>
<span id="cb58-360"><a href="#cb58-360" aria-hidden="true" tabindex="-1"></a>  prob_from_table <span class="ot">&lt;-</span> probability_table[two_char]</span>
<span id="cb58-361"><a href="#cb58-361" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="cb58-362"><a href="#cb58-362" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span> (<span class="fu">is.na</span>(prob_from_table)) {</span>
<span id="cb58-363"><a href="#cb58-363" aria-hidden="true" tabindex="-1"></a>    <span class="fu">return</span>(<span class="dv">1</span> <span class="sc">/</span> <span class="fu">length</span>(war_and_peace_2_characters))</span>
<span id="cb58-364"><a href="#cb58-364" aria-hidden="true" tabindex="-1"></a>  } <span class="cf">else</span>{</span>
<span id="cb58-365"><a href="#cb58-365" aria-hidden="true" tabindex="-1"></a>    <span class="fu">return</span>(prob_from_table)</span>
<span id="cb58-366"><a href="#cb58-366" aria-hidden="true" tabindex="-1"></a>  }</span>
<span id="cb58-367"><a href="#cb58-367" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb58-368"><a href="#cb58-368" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb58-369"><a href="#cb58-369" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb58-370"><a href="#cb58-370" aria-hidden="true" tabindex="-1"></a>We can try our function for a combination in *War and Peace* and a combination that is not:</span>
<span id="cb58-371"><a href="#cb58-371" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb58-374"><a href="#cb58-374" aria-hidden="true" tabindex="-1"></a><span class="in">```{r}</span></span>
<span id="cb58-375"><a href="#cb58-375" aria-hidden="true" tabindex="-1"></a><span class="co"># Try a combination in War and Peace</span></span>
<span id="cb58-376"><a href="#cb58-376" aria-hidden="true" tabindex="-1"></a><span class="fu">get_prob_two_char</span>(<span class="st">"ou"</span>)</span>
<span id="cb58-377"><a href="#cb58-377" aria-hidden="true" tabindex="-1"></a>probability_table[<span class="st">"ou"</span>]</span>
<span id="cb58-378"><a href="#cb58-378" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb58-379"><a href="#cb58-379" aria-hidden="true" tabindex="-1"></a><span class="co"># Try a combination not in War and Peace</span></span>
<span id="cb58-380"><a href="#cb58-380" aria-hidden="true" tabindex="-1"></a><span class="fu">get_prob_two_char</span>(<span class="st">"qq"</span>)</span>
<span id="cb58-381"><a href="#cb58-381" aria-hidden="true" tabindex="-1"></a>probability_table[<span class="st">"qq"</span>]</span>
<span id="cb58-382"><a href="#cb58-382" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb58-383"><a href="#cb58-383" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb58-384"><a href="#cb58-384" aria-hidden="true" tabindex="-1"></a><span class="fu">### Getting the probability of a new text</span></span>
<span id="cb58-385"><a href="#cb58-385" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb58-386"><a href="#cb58-386" aria-hidden="true" tabindex="-1"></a>Now that we have a way to estimate the probability of any two character combination in English, we can use it to score how similar a given text is to English. A first approach, as described above, might be to break the new text into two character chunks, compute the probability of each, and multiply them together.</span>
<span id="cb58-387"><a href="#cb58-387" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb58-388"><a href="#cb58-388" aria-hidden="true" tabindex="-1"></a><span class="co">[</span><span class="ot">`map_dbl()` is a function from the `purrr` package that iterates over each element of an input vector or list, and applies a function to each element. The `_dbl` in the function name means that the expected output is numeric. We need to use `map_dbl()` because our `get_prob_two_char()` function isn't vectorized.</span><span class="co">]</span>{.aside}</span>
<span id="cb58-389"><a href="#cb58-389" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb58-392"><a href="#cb58-392" aria-hidden="true" tabindex="-1"></a><span class="in">```{r}</span></span>
<span id="cb58-393"><a href="#cb58-393" aria-hidden="true" tabindex="-1"></a>sample_text <span class="ot">&lt;-</span> <span class="st">"this is a text"</span></span>
<span id="cb58-394"><a href="#cb58-394" aria-hidden="true" tabindex="-1"></a>sample_text_two_char <span class="ot">&lt;-</span> <span class="fu">break_into_two_chars</span>(sample_text)</span>
<span id="cb58-395"><a href="#cb58-395" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb58-396"><a href="#cb58-396" aria-hidden="true" tabindex="-1"></a>score <span class="ot">&lt;-</span> </span>
<span id="cb58-397"><a href="#cb58-397" aria-hidden="true" tabindex="-1"></a>  purrr<span class="sc">::</span><span class="fu">map_dbl</span>(sample_text_two_char, get_prob_two_char) <span class="sc">|&gt;</span></span>
<span id="cb58-398"><a href="#cb58-398" aria-hidden="true" tabindex="-1"></a>  <span class="fu">prod</span>()</span>
<span id="cb58-399"><a href="#cb58-399" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb58-400"><a href="#cb58-400" aria-hidden="true" tabindex="-1"></a>score</span>
<span id="cb58-401"><a href="#cb58-401" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb58-402"><a href="#cb58-402" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb58-403"><a href="#cb58-403" aria-hidden="true" tabindex="-1"></a>However, we see that the score is an extremely small number, about $10^{-55}$. Therefore, for better numerical precision, we should work on the log scale, and then transform back when we need probabilities. Remember, on the log scale we express products as sums. Below is a function to implement this approach:</span>
<span id="cb58-404"><a href="#cb58-404" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb58-405"><a href="#cb58-405" aria-hidden="true" tabindex="-1"></a>1) Break the text into two character chunks</span>
<span id="cb58-406"><a href="#cb58-406" aria-hidden="true" tabindex="-1"></a>2) Compute the probability of each chunk using our representative English text (*War and Peace*)</span>
<span id="cb58-407"><a href="#cb58-407" aria-hidden="true" tabindex="-1"></a>3) Take the log of each probability</span>
<span id="cb58-408"><a href="#cb58-408" aria-hidden="true" tabindex="-1"></a>4) Sum the probabilities to get a log-likelihood for the text</span>
<span id="cb58-409"><a href="#cb58-409" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb58-412"><a href="#cb58-412" aria-hidden="true" tabindex="-1"></a><span class="in">```{r}</span></span>
<span id="cb58-413"><a href="#cb58-413" aria-hidden="true" tabindex="-1"></a>get_log_lik_text <span class="ot">&lt;-</span> <span class="cf">function</span>(text){</span>
<span id="cb58-414"><a href="#cb58-414" aria-hidden="true" tabindex="-1"></a>  text <span class="sc">|&gt;</span></span>
<span id="cb58-415"><a href="#cb58-415" aria-hidden="true" tabindex="-1"></a>  <span class="fu">break_into_two_chars</span>() <span class="sc">|&gt;</span></span>
<span id="cb58-416"><a href="#cb58-416" aria-hidden="true" tabindex="-1"></a>  purrr<span class="sc">::</span><span class="fu">map_dbl</span>(get_prob_two_char) <span class="sc">|&gt;</span></span>
<span id="cb58-417"><a href="#cb58-417" aria-hidden="true" tabindex="-1"></a>  <span class="fu">log</span>() <span class="sc">|&gt;</span></span>
<span id="cb58-418"><a href="#cb58-418" aria-hidden="true" tabindex="-1"></a>  <span class="fu">sum</span>()</span>
<span id="cb58-419"><a href="#cb58-419" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb58-420"><a href="#cb58-420" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb58-421"><a href="#cb58-421" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb58-422"><a href="#cb58-422" aria-hidden="true" tabindex="-1"></a>Let's see if our score can differentiate English and non-English: a comparison of English words with me hitting random keys.</span>
<span id="cb58-423"><a href="#cb58-423" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb58-426"><a href="#cb58-426" aria-hidden="true" tabindex="-1"></a><span class="in">```{r}</span></span>
<span id="cb58-427"><a href="#cb58-427" aria-hidden="true" tabindex="-1"></a><span class="fu">get_log_lik_text</span>(<span class="st">"This is English text"</span>)</span>
<span id="cb58-428"><a href="#cb58-428" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb58-429"><a href="#cb58-429" aria-hidden="true" tabindex="-1"></a><span class="fu">get_log_lik_text</span>(<span class="st">"fghr gh wghdfrf etfs"</span>)</span>
<span id="cb58-430"><a href="#cb58-430" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb58-431"><a href="#cb58-431" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb58-432"><a href="#cb58-432" aria-hidden="true" tabindex="-1"></a>As expected the log-likelihood for the English text is higher than for the non-English text.</span>
<span id="cb58-433"><a href="#cb58-433" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb58-434"><a href="#cb58-434" aria-hidden="true" tabindex="-1"></a><span class="fu">## Implementing the Metropolis Algorithm</span></span>
<span id="cb58-435"><a href="#cb58-435" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb58-436"><a href="#cb58-436" aria-hidden="true" tabindex="-1"></a>Now we are finally ready to implement our code-breaking algorithm! One helper function we need is a function to swap two elements of a vector. As discussed above, we'll use this to propose a new cipher given the current cipher.</span>
<span id="cb58-437"><a href="#cb58-437" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb58-440"><a href="#cb58-440" aria-hidden="true" tabindex="-1"></a><span class="in">```{r}</span></span>
<span id="cb58-441"><a href="#cb58-441" aria-hidden="true" tabindex="-1"></a>swap <span class="ot">&lt;-</span> <span class="cf">function</span>(x){</span>
<span id="cb58-442"><a href="#cb58-442" aria-hidden="true" tabindex="-1"></a>  <span class="co"># Select two distinct indices</span></span>
<span id="cb58-443"><a href="#cb58-443" aria-hidden="true" tabindex="-1"></a>  rand_indices <span class="ot">&lt;-</span> <span class="fu">sample</span>(<span class="dv">1</span><span class="sc">:</span><span class="fu">length</span>(x), <span class="at">size =</span> <span class="dv">2</span>, <span class="at">replace=</span><span class="cn">FALSE</span>)</span>
<span id="cb58-444"><a href="#cb58-444" aria-hidden="true" tabindex="-1"></a>  element_1 <span class="ot">&lt;-</span> x[rand_indices[<span class="dv">1</span>]]</span>
<span id="cb58-445"><a href="#cb58-445" aria-hidden="true" tabindex="-1"></a>  element_2 <span class="ot">&lt;-</span> x[rand_indices[<span class="dv">2</span>]]</span>
<span id="cb58-446"><a href="#cb58-446" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="cb58-447"><a href="#cb58-447" aria-hidden="true" tabindex="-1"></a>  x[rand_indices[<span class="dv">1</span>]] <span class="ot">&lt;-</span> element_2</span>
<span id="cb58-448"><a href="#cb58-448" aria-hidden="true" tabindex="-1"></a>  x[rand_indices[<span class="dv">2</span>]] <span class="ot">&lt;-</span> element_1</span>
<span id="cb58-449"><a href="#cb58-449" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="cb58-450"><a href="#cb58-450" aria-hidden="true" tabindex="-1"></a>  <span class="fu">return</span>(x)</span>
<span id="cb58-451"><a href="#cb58-451" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb58-452"><a href="#cb58-452" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb58-453"><a href="#cb58-453" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb58-454"><a href="#cb58-454" aria-hidden="true" tabindex="-1"></a>Below is the full algorithm, the same one I ran to create the video at the beginning of this post. The steps correspond to the description I gave above for the Metropolis algorithm, now substituting in the functions we created. I have added detailed comments for each line of the code. Try running it for yourself and use your own example text.</span>
<span id="cb58-455"><a href="#cb58-455" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb58-456"><a href="#cb58-456" aria-hidden="true" tabindex="-1"></a>A few tips:</span>
<span id="cb58-457"><a href="#cb58-457" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb58-458"><a href="#cb58-458" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>The algorithm may take many iterations to converge, sometimes close to 20,000, although this is highly dependent on the cipher chosen and the starting cipher.</span>
<span id="cb58-459"><a href="#cb58-459" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>Since this is a relatively short text, it may take more iterations to decode. Long texts contain more information, and so are more easily decoded.</span>
<span id="cb58-460"><a href="#cb58-460" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>If the chain doesn't seem to be converging, try a new random seed. I had to try a few random seeds for the algorithm to converge in a reasonable number of iterations^<span class="co">[</span><span class="ot">While this strategy of restarting misbehaving Markov chains isn't a good strategy for other applications of MCMC like Bayesian statistics, it's perfectly reasonable for the optimization task we are performing here.</span><span class="co">]</span>.</span>
<span id="cb58-461"><a href="#cb58-461" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb58-464"><a href="#cb58-464" aria-hidden="true" tabindex="-1"></a><span class="in">```{r}</span></span>
<span id="cb58-465"><a href="#cb58-465" aria-hidden="true" tabindex="-1"></a><span class="co">#| eval: false</span></span>
<span id="cb58-466"><a href="#cb58-466" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb58-467"><a href="#cb58-467" aria-hidden="true" tabindex="-1"></a>plaintext <span class="ot">&lt;-</span> <span class="st">"to be or not to be that is the question whether tis nobler in the mind to suffer the slings and arrows of outrageous fortune or to take arms against a sea of troubles"</span></span>
<span id="cb58-468"><a href="#cb58-468" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb58-469"><a href="#cb58-469" aria-hidden="true" tabindex="-1"></a><span class="co"># Generate a random cipher to be the true cipher</span></span>
<span id="cb58-470"><a href="#cb58-470" aria-hidden="true" tabindex="-1"></a>true_cipher <span class="ot">&lt;-</span> <span class="fu">generate_cipher</span>()</span>
<span id="cb58-471"><a href="#cb58-471" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb58-472"><a href="#cb58-472" aria-hidden="true" tabindex="-1"></a><span class="co"># Encode the plaintext</span></span>
<span id="cb58-473"><a href="#cb58-473" aria-hidden="true" tabindex="-1"></a>ciphered_text <span class="ot">&lt;-</span> <span class="fu">encode_text</span>(<span class="at">text =</span> plaintext,</span>
<span id="cb58-474"><a href="#cb58-474" aria-hidden="true" tabindex="-1"></a>                             <span class="at">cipher =</span> true_cipher)</span>
<span id="cb58-475"><a href="#cb58-475" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb58-476"><a href="#cb58-476" aria-hidden="true" tabindex="-1"></a><span class="co"># Create another random cipher to be the starting cipher for the Markov Chain</span></span>
<span id="cb58-477"><a href="#cb58-477" aria-hidden="true" tabindex="-1"></a>current_cipher <span class="ot">&lt;-</span> <span class="fu">generate_cipher</span>()</span>
<span id="cb58-478"><a href="#cb58-478" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb58-479"><a href="#cb58-479" aria-hidden="true" tabindex="-1"></a><span class="co"># A counter to track how many decoded texts have been accepted</span></span>
<span id="cb58-480"><a href="#cb58-480" aria-hidden="true" tabindex="-1"></a>i <span class="ot">&lt;-</span> <span class="dv">0</span></span>
<span id="cb58-481"><a href="#cb58-481" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb58-482"><a href="#cb58-482" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> (iter <span class="cf">in</span> <span class="dv">1</span><span class="sc">:</span><span class="dv">50000</span>) {</span>
<span id="cb58-483"><a href="#cb58-483" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="cb58-484"><a href="#cb58-484" aria-hidden="true" tabindex="-1"></a>  <span class="co"># Propose a new cipher by swapping two letters in the current cipher</span></span>
<span id="cb58-485"><a href="#cb58-485" aria-hidden="true" tabindex="-1"></a>  proposed_cipher <span class="ot">&lt;-</span> <span class="fu">swap</span>(current_cipher)</span>
<span id="cb58-486"><a href="#cb58-486" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="cb58-487"><a href="#cb58-487" aria-hidden="true" tabindex="-1"></a>  <span class="co"># Text decoded from the proposal cipher</span></span>
<span id="cb58-488"><a href="#cb58-488" aria-hidden="true" tabindex="-1"></a>  decoded_text_proposed <span class="ot">&lt;-</span> <span class="fu">decode_text</span>(ciphered_text,</span>
<span id="cb58-489"><a href="#cb58-489" aria-hidden="true" tabindex="-1"></a>                              <span class="at">cipher =</span> proposed_cipher)</span>
<span id="cb58-490"><a href="#cb58-490" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="cb58-491"><a href="#cb58-491" aria-hidden="true" tabindex="-1"></a>  <span class="co"># Text decoded from the current cipher</span></span>
<span id="cb58-492"><a href="#cb58-492" aria-hidden="true" tabindex="-1"></a>  decoded_text_current <span class="ot">&lt;-</span> <span class="fu">decode_text</span>(ciphered_text,</span>
<span id="cb58-493"><a href="#cb58-493" aria-hidden="true" tabindex="-1"></a>                              <span class="at">cipher =</span> current_cipher)</span>
<span id="cb58-494"><a href="#cb58-494" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="cb58-495"><a href="#cb58-495" aria-hidden="true" tabindex="-1"></a>  <span class="co"># Log-likelihood of the decoded text from the proposal cipher</span></span>
<span id="cb58-496"><a href="#cb58-496" aria-hidden="true" tabindex="-1"></a>  proposed_log_lik <span class="ot">&lt;-</span> <span class="fu">get_log_lik_text</span>(decoded_text_proposed)</span>
<span id="cb58-497"><a href="#cb58-497" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="cb58-498"><a href="#cb58-498" aria-hidden="true" tabindex="-1"></a>  <span class="co"># Log-likelihood of the decoded text from the current cipher</span></span>
<span id="cb58-499"><a href="#cb58-499" aria-hidden="true" tabindex="-1"></a>  current_log_lik <span class="ot">&lt;-</span> <span class="fu">get_log_lik_text</span>(decoded_text_current)</span>
<span id="cb58-500"><a href="#cb58-500" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="cb58-501"><a href="#cb58-501" aria-hidden="true" tabindex="-1"></a>  <span class="co"># Acceptance probability of the proposal, defined by the Metropolis algorithm</span></span>
<span id="cb58-502"><a href="#cb58-502" aria-hidden="true" tabindex="-1"></a>  <span class="co"># Remember that subtraction on the log-scale is division on the probability</span></span>
<span id="cb58-503"><a href="#cb58-503" aria-hidden="true" tabindex="-1"></a>  <span class="co"># scale. We exponentiate to get back to the probability scale.</span></span>
<span id="cb58-504"><a href="#cb58-504" aria-hidden="true" tabindex="-1"></a>  acceptance_probability <span class="ot">&lt;-</span> <span class="fu">min</span>(<span class="dv">1</span>, <span class="fu">exp</span>(proposed_log_lik <span class="sc">-</span> current_log_lik))</span>
<span id="cb58-505"><a href="#cb58-505" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="cb58-506"><a href="#cb58-506" aria-hidden="true" tabindex="-1"></a>  <span class="co"># Accept or not with probability given by `acceptance_probability`</span></span>
<span id="cb58-507"><a href="#cb58-507" aria-hidden="true" tabindex="-1"></a>  accept <span class="ot">&lt;-</span> <span class="fu">sample</span>(<span class="fu">c</span>(<span class="cn">TRUE</span>, <span class="cn">FALSE</span>),</span>
<span id="cb58-508"><a href="#cb58-508" aria-hidden="true" tabindex="-1"></a>                   <span class="at">size=</span><span class="dv">1</span>,</span>
<span id="cb58-509"><a href="#cb58-509" aria-hidden="true" tabindex="-1"></a>                   <span class="at">prob =</span> <span class="fu">c</span>(acceptance_probability,</span>
<span id="cb58-510"><a href="#cb58-510" aria-hidden="true" tabindex="-1"></a>                            <span class="dv">1</span><span class="sc">-</span>acceptance_probability))</span>
<span id="cb58-511"><a href="#cb58-511" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="cb58-512"><a href="#cb58-512" aria-hidden="true" tabindex="-1"></a>  <span class="co"># IF we accept the proposal, set the proposal cipher as the current cipher</span></span>
<span id="cb58-513"><a href="#cb58-513" aria-hidden="true" tabindex="-1"></a>  <span class="co"># ELSE, go on to the next iteration</span></span>
<span id="cb58-514"><a href="#cb58-514" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span> (accept) {</span>
<span id="cb58-515"><a href="#cb58-515" aria-hidden="true" tabindex="-1"></a>    current_cipher <span class="ot">&lt;-</span> proposed_cipher</span>
<span id="cb58-516"><a href="#cb58-516" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb58-517"><a href="#cb58-517" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Print the text as decoded by the current cipher</span></span>
<span id="cb58-518"><a href="#cb58-518" aria-hidden="true" tabindex="-1"></a>    <span class="fu">print</span>(glue<span class="sc">::</span><span class="fu">glue</span>(<span class="st">"Iteration {i}: {decoded_text_proposed}"</span>))</span>
<span id="cb58-519"><a href="#cb58-519" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb58-520"><a href="#cb58-520" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Increment the counter so that we can keep track of acceptances</span></span>
<span id="cb58-521"><a href="#cb58-521" aria-hidden="true" tabindex="-1"></a>    <span class="co"># This is just for printing the output</span></span>
<span id="cb58-522"><a href="#cb58-522" aria-hidden="true" tabindex="-1"></a>    i <span class="ot">&lt;-</span> i <span class="sc">+</span> <span class="dv">1</span></span>
<span id="cb58-523"><a href="#cb58-523" aria-hidden="true" tabindex="-1"></a>  }</span>
<span id="cb58-524"><a href="#cb58-524" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb58-525"><a href="#cb58-525" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb58-526"><a href="#cb58-526" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb58-527"><a href="#cb58-527" aria-hidden="true" tabindex="-1"></a>For clarity, here's the same code without comments.</span>
<span id="cb58-528"><a href="#cb58-528" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb58-531"><a href="#cb58-531" aria-hidden="true" tabindex="-1"></a><span class="in">```{r}</span></span>
<span id="cb58-532"><a href="#cb58-532" aria-hidden="true" tabindex="-1"></a><span class="co">#| eval: false</span></span>
<span id="cb58-533"><a href="#cb58-533" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb58-534"><a href="#cb58-534" aria-hidden="true" tabindex="-1"></a>plaintext <span class="ot">&lt;-</span> <span class="st">"to be or not to be that is the question whether tis nobler in the mind to suffer the slings and arrows of outrageous fortune or to take arms against a sea of troubles"</span></span>
<span id="cb58-535"><a href="#cb58-535" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb58-536"><a href="#cb58-536" aria-hidden="true" tabindex="-1"></a>true_cipher <span class="ot">&lt;-</span> <span class="fu">generate_cipher</span>()</span>
<span id="cb58-537"><a href="#cb58-537" aria-hidden="true" tabindex="-1"></a>ciphered_text <span class="ot">&lt;-</span> <span class="fu">encode_text</span>(<span class="at">text =</span> plaintext,</span>
<span id="cb58-538"><a href="#cb58-538" aria-hidden="true" tabindex="-1"></a>                             <span class="at">cipher =</span> true_cipher)</span>
<span id="cb58-539"><a href="#cb58-539" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb58-540"><a href="#cb58-540" aria-hidden="true" tabindex="-1"></a>current_cipher <span class="ot">&lt;-</span> <span class="fu">generate_cipher</span>()</span>
<span id="cb58-541"><a href="#cb58-541" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb58-542"><a href="#cb58-542" aria-hidden="true" tabindex="-1"></a>i <span class="ot">&lt;-</span> <span class="dv">0</span></span>
<span id="cb58-543"><a href="#cb58-543" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb58-544"><a href="#cb58-544" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> (iter <span class="cf">in</span> <span class="dv">1</span><span class="sc">:</span><span class="dv">50000</span>) {</span>
<span id="cb58-545"><a href="#cb58-545" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="cb58-546"><a href="#cb58-546" aria-hidden="true" tabindex="-1"></a>  proposed_cipher <span class="ot">&lt;-</span> <span class="fu">swap</span>(current_cipher)</span>
<span id="cb58-547"><a href="#cb58-547" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="cb58-548"><a href="#cb58-548" aria-hidden="true" tabindex="-1"></a>  decoded_text_proposed <span class="ot">&lt;-</span> <span class="fu">decode_text</span>(ciphered_text,</span>
<span id="cb58-549"><a href="#cb58-549" aria-hidden="true" tabindex="-1"></a>                              <span class="at">cipher =</span> proposed_cipher)</span>
<span id="cb58-550"><a href="#cb58-550" aria-hidden="true" tabindex="-1"></a>  decoded_text_current <span class="ot">&lt;-</span> <span class="fu">decode_text</span>(ciphered_text,</span>
<span id="cb58-551"><a href="#cb58-551" aria-hidden="true" tabindex="-1"></a>                              <span class="at">cipher =</span> current_cipher)</span>
<span id="cb58-552"><a href="#cb58-552" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="cb58-553"><a href="#cb58-553" aria-hidden="true" tabindex="-1"></a>  proposed_log_lik <span class="ot">&lt;-</span> <span class="fu">get_log_lik_text</span>(decoded_text_proposed)</span>
<span id="cb58-554"><a href="#cb58-554" aria-hidden="true" tabindex="-1"></a>  current_log_lik <span class="ot">&lt;-</span> <span class="fu">get_log_lik_text</span>(decoded_text_current)</span>
<span id="cb58-555"><a href="#cb58-555" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="cb58-556"><a href="#cb58-556" aria-hidden="true" tabindex="-1"></a>  acceptance_probability <span class="ot">&lt;-</span> <span class="fu">min</span>(<span class="dv">1</span>, <span class="fu">exp</span>(proposed_log_lik <span class="sc">-</span> current_log_lik))</span>
<span id="cb58-557"><a href="#cb58-557" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="cb58-558"><a href="#cb58-558" aria-hidden="true" tabindex="-1"></a>  accept <span class="ot">&lt;-</span> <span class="fu">sample</span>(<span class="fu">c</span>(<span class="cn">TRUE</span>, <span class="cn">FALSE</span>),</span>
<span id="cb58-559"><a href="#cb58-559" aria-hidden="true" tabindex="-1"></a>                   <span class="at">size=</span><span class="dv">1</span>,</span>
<span id="cb58-560"><a href="#cb58-560" aria-hidden="true" tabindex="-1"></a>                   <span class="at">prob =</span> <span class="fu">c</span>(acceptance_probability,</span>
<span id="cb58-561"><a href="#cb58-561" aria-hidden="true" tabindex="-1"></a>                            <span class="dv">1</span><span class="sc">-</span>acceptance_probability))</span>
<span id="cb58-562"><a href="#cb58-562" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="cb58-563"><a href="#cb58-563" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span> (accept) {</span>
<span id="cb58-564"><a href="#cb58-564" aria-hidden="true" tabindex="-1"></a>    current_cipher <span class="ot">&lt;-</span> proposed_cipher</span>
<span id="cb58-565"><a href="#cb58-565" aria-hidden="true" tabindex="-1"></a>    <span class="fu">print</span>(glue<span class="sc">::</span><span class="fu">glue</span>(<span class="st">"Iteration {i}: {decoded_text_proposed}"</span>))</span>
<span id="cb58-566"><a href="#cb58-566" aria-hidden="true" tabindex="-1"></a>    i <span class="ot">&lt;-</span> i <span class="sc">+</span> <span class="dv">1</span></span>
<span id="cb58-567"><a href="#cb58-567" aria-hidden="true" tabindex="-1"></a>  }</span>
<span id="cb58-568"><a href="#cb58-568" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb58-569"><a href="#cb58-569" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb58-570"><a href="#cb58-570" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb58-571"><a href="#cb58-571" aria-hidden="true" tabindex="-1"></a></span>
</code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div></div></div></div></div>
</div> <!-- /content -->



</body></html>